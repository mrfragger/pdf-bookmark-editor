<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Bookmark Editor</title>
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#667eea">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="PDF Editor">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            color: #fff;
            height: 100vh;
            overflow: hidden;
        }
        
        .app-layout {
            display: flex;
            height: 100vh;
        }
        
        .pdf-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #16213e;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .pdf-header {
            padding: 15px 20px;
            background: rgba(0, 0, 0, 0.2);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .file-input-wrapper {
            position: relative;
        }
        
        input[type="file"] {
            display: none;
        }
        
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        .btn-primary:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }
        
        .pdf-info {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 20px;
            color: #aaa;
        }
        
        .page-nav {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .page-nav button {
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
        }
        
        .page-nav button:hover:not(:disabled) {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .page-nav button:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
        
        .page-nav input {
            width: 60px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 6px;
            border-radius: 4px;
            text-align: center;
        }
        
        .pdf-viewer-container {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            background: #0f1419;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            position: relative;
        }
        
        #pdfViewer {
            max-width: 100%;
            display: none;
        }
        
        #pdfViewer.active {
            display: block;
        }
        
        .pdf-page {
            margin-bottom: 20px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }
        
        /* Right Panel - Bookmarks */
        .bookmarks-panel {
            width: 400px;
            display: flex;
            flex-direction: column;
            background: #1a1a2e;
        }
        
        .bookmarks-header {
            padding: 12px 20px;
            background: rgba(0, 0, 0, 0.2);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .bookmarks-header h2 {
            margin-bottom: 8px;
            font-size: 1.2em;
        }
        
        .keyboard-shortcuts {
            background: rgba(102, 126, 234, 0.1);
            padding: 8px 10px;
            border-radius: 6px;
            font-size: 11px;
            line-height: 1.5;
            color: #aaa;
        }
        
        .keyboard-shortcuts kbd {
            background: rgba(0, 0, 0, 0.3);
            padding: 2px 6px;
            border-radius: 3px;
            font-family: monospace;
            color: #fff;
            font-size: 11px;
        }
        
        .bookmarks-list {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
        }
        
        .bookmarks-list::-webkit-scrollbar {
            width: 8px;
        }
        
        .bookmarks-list::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
        }
        
        .bookmarks-list::-webkit-scrollbar-thumb {
            background: rgba(102, 126, 234, 0.5);
            border-radius: 4px;
        }
        
        .bookmark-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 10px 12px;
            margin-bottom: 8px;
            border-radius: 6px;
            border-left: 3px solid #667eea;
            transition: all 0.2s;
        }
        
        .bookmark-item:hover {
            background: rgba(255, 255, 255, 0.08);
        }
        
        .bookmark-item.level-2 {
            border-left-color: #38ef7d;
            margin-left: 20px;
        }
        
        .bookmark-item.level-3 {
            border-left-color: #f39c12;
            margin-left: 40px;
        }
        
        .bookmark-item-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }
        
        .bookmark-page {
            background: rgba(102, 126, 234, 0.2);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
        }
        
        .bookmark-page.clickable {
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .bookmark-page.clickable:hover {
            background: rgba(102, 126, 234, 0.4);
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
        }
        
        .bookmark-page.clickable:active {
            transform: translateY(0);
        }
        
        .bookmark-item input {
            width: 100%;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #fff;
            padding: 8px;
            border-radius: 4px;
            font-size: 14px;
        }
        
        .bookmark-item input:focus {
            outline: none;
            border-color: rgba(102, 126, 234, 0.5);
        }
        
        .bookmark-actions {
            display: flex;
            gap: 6px;
        }
        
        .pdf-page {
            display: block;
        }

        .page-editor-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(5px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            animation: fadeIn 0.2s ease;
            padding: 10px 0;
            overflow: hidden;
        }
        
        .page-editor-modal.hidden {
            display: none;
        }
        
        .page-editor-content {
            background: #1a1a2e;
            border-radius: 12px;
            width: 95%;
            height: calc(100vh - 20px);
            max-width: 1400px;
            display: flex;
            flex-direction: column;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            animation: slideUp 0.3s ease;
            overflow: hidden;
        }
        
        .page-editor-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 25px;
            background: rgba(0, 0, 0, 0.2);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .page-editor-toolbar {
            display: flex;
            gap: 10px;
            align-items: center;
            padding: 10px 15px;
            background: rgba(0, 0, 0, 0.3);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            flex-wrap: wrap;
        }
        
        .toolbar-group {
            display: flex;
            gap: 8px;
            align-items: center;
            padding-right: 15px;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .toolbar-group:last-child {
            border-right: none;
        }
        
        .toolbar-label {
            font-size: 12px;
            color: #888;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .page-grid-container {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
            background: #0f1419;
        }
        
        .page-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 20px;
        }
        
        .page-thumbnail {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            padding: 12px;
            cursor: pointer;
            border: 3px solid transparent;
            transition: all 0.2s;
            position: relative;
        }
        
        .page-thumbnail:hover {
            background: rgba(255, 255, 255, 0.08);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        
        .page-thumbnail.selected {
            border-color: #667eea;
            background: rgba(102, 126, 234, 0.1);
        }
        
        .page-thumbnail.dragging {
            opacity: 0.5;
        }
        
        .page-thumbnail.drag-over {
            border-color: #38ef7d;
            background: rgba(56, 239, 125, 0.1);
        }
        
        .page-thumbnail-canvas {
            width: 100%;
            height: auto;
            border-radius: 4px;
            background: white;
            display: block;
        }
        
        .page-thumbnail-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 10px;
            font-size: 13px;
        }
        
        .page-number {
            color: #667eea;
            font-weight: 600;
        }
        
        .page-size {
            color: #888;
            font-size: 11px;
        }
        
        .page-checkbox {
            position: absolute;
            top: 18px;
            left: 18px;
            width: 24px;
            height: 24px;
            cursor: pointer;
            z-index: 10;
        }

        .page-thumbnail.deleted {
            pointer-events: none;
            opacity: 0.4;
            position: relative;
        }
        
        .page-thumbnail.deleted::before {
            content: 'üóëÔ∏è';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 72px;
            z-index: 100;
            text-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
            pointer-events: none;
        }
        
        .page-thumbnail.deleted::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 8px;
            z-index: 99;
            pointer-events: none;
        }
        
        .rotation-indicator {
            position: absolute;
            top: 18px;
            right: 18px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
        }

        .page-editor-actions {
            display: flex;
            gap: 12px;
            padding: 12px 25px;
            background: rgba(0, 0, 0, 0.2);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            align-items: center;
        }

       .page-editor-actions .btn {
           padding: 10px 16px;
           font-size: 14px;
           white-space: nowrap;
       }
        
        .selection-info {
            flex: 1;
            display: flex;
            align-items: center;
            color: #888;
            font-size: 13px;
            white-space: nowrap;
        }
        
        .selection-info strong {
            color: #667eea;
            margin: 0 4px;
        }
        
        .btn-icon {
            padding: 8px 16px;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .split-range-input {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 13px;
            width: 200px;
        }
        
        .split-range-input:focus {
            outline: none;
            border-color: rgba(102, 126, 234, 0.5);
        }
        
        .split-range-input::placeholder {
            color: #666;
        }
        
        .textLayer {
            position: absolute;
            left: 0;
            top: 0;
            right: 0;
            bottom: 0;
            overflow: hidden;
            opacity: 0.4;
            line-height: 1;
            --scale-factor: 1.5;
        }
        
        .textLayer > span {
            color: transparent;
            position: absolute;
            white-space: pre;
            cursor: text;
            transform-origin: 0% 0%;
        }
        
        .textLayer ::selection {
            background: rgba(255, 235, 59, 0.6);
            color: inherit;
        }
        
        .textLayer ::-moz-selection {
            background: rgba(255, 235, 59, 0.6);
            color: inherit;
        }
        
        .btn-small {
            padding: 4px 8px;
            font-size: 12px;
        }
        
        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }
        
        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.15);
        }
        
        .btn-delete {
            background: transparent;
            color: #e74c3c;
            border: 1px solid rgba(231, 76, 60, 0.3);
        }
        
        .btn-delete:hover {
            background: rgba(231, 76, 60, 0.2);
            border-color: rgba(231, 76, 60, 0.5);
        }
        
        
        .bookmarks-footer {
            padding: 15px;
            background: rgba(0, 0, 0, 0.2);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .footer-buttons {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
        }
        
        .footer-buttons .btn {
            flex: 1;
            font-size: 11px;
            padding: 8px 10px;
        }
        
        .btn-success {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            width: 100%;
            padding: 14px;
            font-size: 16px;
        }
        
        .btn-success:hover:not(:disabled) {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }
        
        .btn-success:disabled {
            background: #555;
            cursor: not-allowed;
            opacity: 0.5;
        }
        
        .empty-state {
            text-align: center;
            padding: 40px 20px;
            color: #666;
        }
        
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(5px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            animation: fadeIn 0.2s ease;
        }
        
        .modal.hidden {
            display: none;
        }
        
        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }
        
        .modal-content {
            background: #1a1a2e;
            padding: 0;
            border-radius: 12px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            animation: slideUp 0.3s ease;
        }
        
        @keyframes slideUp {
            from {
                transform: translateY(30px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 25px;
            background: rgba(0, 0, 0, 0.2);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .modal-header h3 {
            margin: 0;
            font-size: 1.3em;
        }
        
        .btn-close {
            background: transparent;
            border: none;
            color: #aaa;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            transition: all 0.2s;
        }
        
        .btn-close:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
        }
        
        .modal-content > p {
            color: #aaa;
            margin: 0;
            padding: 15px 25px;
            font-size: 14px;
            background: rgba(102, 126, 234, 0.05);
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }
        
        .merge-file-list {
            padding: 20px 25px;
            max-height: 400px;
            overflow-y: auto;
        }
        
        .merge-file-list::-webkit-scrollbar {
            width: 8px;
        }
        
        .merge-file-list::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
        }
        
        .merge-file-list::-webkit-scrollbar-thumb {
            background: rgba(102, 126, 234, 0.5);
            border-radius: 4px;
        }
        
        .merge-file-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            gap: 12px;
            cursor: grab;
            border: 2px solid transparent;
            transition: all 0.2s;
        }
        
        .merge-file-item:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(102, 126, 234, 0.3);
        }
        
        .merge-file-item.dragging {
            opacity: 0.5;
            cursor: grabbing;
        }
        
        .merge-file-item.drag-over {
            border-color: rgba(102, 126, 234, 0.8);
            background: rgba(102, 126, 234, 0.1);
        }
        
        .drag-handle {
            color: #666;
            font-size: 20px;
            cursor: grab;
            user-select: none;
        }
        
        .merge-file-item.dragging .drag-handle {
            cursor: grabbing;
        }
        
        .file-order {
            background: rgba(102, 126, 234, 0.3);
            color: white;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 13px;
            flex-shrink: 0;
        }
        
        .file-info {
            flex: 1;
            min-width: 0;
        }
        
        .file-name {
            font-weight: 600;
            color: #fff;
            margin-bottom: 4px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .file-pages {
            font-size: 12px;
            color: #888;
        }
        
        .remove-file {
            background: transparent;
            border: 1px solid rgba(231, 76, 60, 0.3);
            color: #e74c3c;
            padding: 6px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
            flex-shrink: 0;
        }
        
        .remove-file:hover {
            background: rgba(231, 76, 60, 0.2);
            border-color: rgba(231, 76, 60, 0.5);
        }
        
        .modal-actions {
            display: flex;
            gap: 12px;
            padding: 20px 25px;
            background: rgba(0, 0, 0, 0.2);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .modal-actions .btn {
            flex: 1;
            padding: 12px;
        }
        
        .empty-merge-list {
            text-align: center;
            padding: 40px 20px;
            color: #666;
        }
        
        .toast {
            position: fixed;
            bottom: 30px;
            right: 30px;
            background: rgba(102, 126, 234, 0.95);
            backdrop-filter: blur(10px);
            color: white;
            padding: 15px 20px;
            border-radius: 8px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            transform: translateX(400px);
            transition: transform 0.3s ease;
            z-index: 10000; /* Increased z-index */
            max-width: 350px;
            word-wrap: break-word;
        }
        
        .toast.show {
            transform: translateX(0);
        }
        
        .toast.error {
            background: rgba(231, 76, 60, 0.95);
        }
        
        .toast.success {
            background: rgba(17, 153, 142, 0.95);
        }
        
        .toast.info {
            background: rgba(102, 126, 234, 0.95);
        }
        
        @keyframes bookmark-highlight {
            0% {
                background: rgba(102, 126, 234, 0.4);
                transform: scale(1.02);
            }
            100% {
                background: rgba(255, 255, 255, 0.05);
                transform: scale(1);
            }
        }
        
        .bookmark-item.newly-added {
            animation: bookmark-highlight 0.6s ease-out;
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #aaa;
            font-size: 18px;
            pointer-events: none;
        }
        
        .loading.hidden {
            display: none;
        }
        
        @media (max-width: 1024px) {
            .app-layout {
                flex-direction: column;
            }
        
            .bookmarks-panel {
                width: 100%;
                max-height: 50vh;
            }
        }
    </style>
</head>
<body>
    <div class="app-layout">
        <div class="pdf-panel">
            <div class="pdf-header">
                <div class="file-input-wrapper">
                    <input type="file" id="pdfInput" accept=".pdf">
                    <label for="pdfInput" class="btn btn-primary">
                        Open PDF
                    </label>
                </div>
                <div class="file-input-wrapper">
                    <input type="file" id="mergePdfInput" accept=".pdf" multiple>
                    <label for="mergePdfInput" class="btn btn-primary">
                        Merge PDFs
                    </label>
                </div>
                <button id="openPageEditor" class="btn btn-primary" disabled>
                    Edit Pages
                </button>
                <div class="pdf-info">
                    <span id="pdfName"></span>
                    <div id="currentPageDisplay" style="color: #667eea; font-weight: 600; line-height: 1.3; text-align: right; min-width: 80px;"></div>
                </div>
            </div>
            <div class="pdf-viewer-container" id="pdfViewerContainer">
                <div class="loading" id="loading">Select a PDF to get started</div>
                <canvas id="pdfViewer"></canvas>
            </div>
        </div>

        <div class="bookmarks-panel">
            <div class="bookmarks-header">
                <h2>Add / Edit Bookmarks</h2>
                <div class="keyboard-shortcuts">
                    <kbd>Cmd/Ctrl</kbd> + <kbd>A</kbd> Chapter (Level 1)<br>
                    <kbd>Cmd/Ctrl</kbd> + <kbd>S</kbd> Section (Level 2)<br>
                    <kbd>Cmd/Ctrl</kbd> + <kbd>D</kbd> Subsection (Level 3)
                </div>
            </div>
            
            <div class="bookmarks-list" id="bookmarksList">
                <div class="empty-state">
                    <p>üìë No bookmarks yet</p>
                    <p style="margin-top: 10px; font-size: 13px;">
                        Select text in PDF and use keyboard shortcuts
                    </p>
                </div>
            </div>

            <div class="bookmarks-footer">
                <div class="footer-buttons">
                    <div class="file-input-wrapper">
                        <input type="file" id="importInput" accept=".txt">
                        <label for="importInput" class="btn btn-secondary btn-small">
                             Import
                        </label>
                    </div>
                    <button id="exportBtn" class="btn btn-secondary btn-small">Export</button>
                    <button id="loadExistingBtn" class="btn btn-secondary btn-small" disabled>
                        Load Existing
                    </button>
                </div>
                <button id="applyBookmarksBtn" class="btn btn-success" disabled>
                    Create PDF with Bookmarks
                </button>   
            </div>

            <div id="pageEditorModal" class="page-editor-modal hidden">
                <div class="page-editor-content">
                    <div class="page-editor-toolbar">
                        <div class="toolbar-group">
                            <span class="toolbar-label">Select</span>
                            <button id="selectAllPages" class="btn btn-secondary btn-small">All</button>
                            <button id="selectNonePages" class="btn btn-secondary btn-small">None</button>
                            <button id="selectEvenPages" class="btn btn-secondary btn-small">Even</button>
                            <button id="selectOddPages" class="btn btn-secondary btn-small">Odd</button>
                            <button id="selectInvertPages" class="btn btn-secondary btn-small">Invert</button>
                        </div>
                        
                        <div class="toolbar-group">
                            <span class="toolbar-label">Rotate</span>
                            <button id="rotateLeft" class="btn btn-secondary btn-small btn-icon" title="Rotate 90¬∞ Left">‚Ü∫ 90¬∞</button>
                            <button id="rotateRight" class="btn btn-secondary btn-small btn-icon" title="Rotate 90¬∞ Right">‚Üª 90¬∞</button>
                            <button id="rotate180" class="btn btn-secondary btn-small btn-icon" title="Rotate 180¬∞">‚Üª 180¬∞</button>
                        </div>
                        
                        <div class="toolbar-group">
                            <span class="toolbar-label">Actions</span>
                            <button id="deleteSelected" class="btn btn-delete btn-small btn-icon">üóëÔ∏è Delete</button>
                        </div>
                        
                        <div class="toolbar-group">
                            <span class="toolbar-label">Range</span>
                            <input type="text" id="splitRangeInput" class="split-range-input" placeholder="e.g., 1-5, 10, 15-20">
                            <button id="selectRange" class="btn btn-secondary btn-small">Select</button>
                            <button id="splitExtract" class="btn btn-primary btn-small">Extract</button>
                        </div>
            
                        <div style="flex: 1;"></div>
                        
                        <button id="closePageEditor" class="btn btn-secondary btn-small">‚úï Close</button>
                    </div>
            
                    <div class="page-grid-container" id="pageGridContainer">
                        <div id="pageGrid" class="page-grid"></div>
                    </div>
            
                    <div class="page-editor-actions">
                        <div class="selection-info">
                            <span id="selectionCount">0 pages selected</span>
                        </div>
                        <button id="cancelPageEdit" class="btn btn-secondary">Cancel</button>
                        <button id="undoButton" class="btn btn-secondary" disabled>
                            ‚Ü∂ Undo <kbd>Cmd/Ctrl+Z</kbd>
                        </button>
                        <button id="applyPageChanges" class="btn btn-success">Apply Changes</button>
                    </div>
                </div>
            </div>
            </div>
        </div>
    </div>

    <div id="toast" class="toast"></div>

    <div id="mergeModal" class="modal hidden">
        <div class="modal-content">
            <div class="modal-header">
                <h3>üîó Merge PDFs</h3>
                <button id="closeMergeModal" class="btn-close">‚úï</button>
            </div>
            <p>Drag files to reorder them before merging</p>
            <div id="mergeFileList" class="merge-file-list"></div>
            <div class="modal-actions">
                <button id="cancelMerge" class="btn btn-secondary">Cancel</button>
                <button id="confirmMerge" class="btn btn-success">Merge PDFs</button>
            </div>
        </div>
    </div>

    <script src="pdf.min.js"></script>
    <script src="pdf-lib.min.js"></script>
    <script>
pdfjsLib.GlobalWorkerOptions.workerSrc = 'pdf.worker.min.js';

const { PDFDocument, PDFName, PDFString, PDFNumber } = PDFLib;

let pdfDoc = null;
let pdfBytes = null;
let pdfFileName = '';
let bookmarks = [];
let currentPage = 1;
let totalPages = 0;
let pdfJsDoc = null;
let renderTask = null;
let originalFile = null;
let toastTimeout = null;
let lastTitleCaseOperation = null;
let mergeFiles = [];
let draggedElement = null;
let visiblePages = new Set();
let pageCache = new Map();
let undoStack = [];

const pdfInput = document.getElementById('pdfInput');
const pdfName = document.getElementById('pdfName');
const pdfViewer = document.getElementById('pdfViewer');
const pdfViewerContainer = document.getElementById('pdfViewerContainer');
const loadingEl = document.getElementById('loading');
const bookmarksList = document.getElementById('bookmarksList');
const importInput = document.getElementById('importInput');
const exportBtn = document.getElementById('exportBtn');
const applyBookmarksBtn = document.getElementById('applyBookmarksBtn');
const mergePdfInput = document.getElementById('mergePdfInput');
const mergeModal = document.getElementById('mergeModal');
const mergeFileList = document.getElementById('mergeFileList');
const confirmMergeBtn = document.getElementById('confirmMerge');
const cancelMergeBtn = document.getElementById('cancelMerge');
const closeMergeModalBtn = document.getElementById('closeMergeModal');
const PAGES_TO_RENDER_AHEAD = 2;
const INITIAL_PAGES_TO_LOAD = 3;
const MAX_UNDO_STACK = 50;

function saveUndoState(action) {
    const state = {
        action: action,
        pages: JSON.parse(JSON.stringify(pageEditorState.reorderedPages)),
        selectedPages: new Set(pageEditorState.selectedPages),
        timestamp: Date.now()
    };
    
    undoStack.push(state);
    
    if (undoStack.length > MAX_UNDO_STACK) {
        undoStack.shift();
    }
    
    updateUndoButton();
}

function undo() {
    if (undoStack.length === 0) {
        showToast('Nothing to undo', 'info');
        return;
    }
    
    const previousState = undoStack.pop();
    
    pageEditorState.reorderedPages = JSON.parse(JSON.stringify(previousState.pages));
    pageEditorState.selectedPages = new Set(previousState.selectedPages);
    
    const container = document.getElementById('pageGridContainer');
    const scrollPos = container.scrollTop;
    
    renderPageGrid().then(() => {
        container.scrollTop = scrollPos;
        syncCheckboxes();
        updateSelectionInfo();
    });
    
    showToast(`Undid: ${previousState.action}`, 'success');
    
    updateUndoButton();
}

function updateUndoButton() {
    const btn = document.getElementById('undoButton');
    btn.disabled = undoStack.length === 0;
}

document.getElementById('undoButton').addEventListener('click', undo);

document.addEventListener('keydown', (e) => {
    const modifier = (navigator.platform.toUpperCase().indexOf('MAC') >= 0) ? e.metaKey : e.ctrlKey;
    
    if (modifier && e.key === 'z' && !pageEditorModal.classList.contains('hidden')) {
        e.preventDefault();
        undo();
    }
});

mergePdfInput.addEventListener('change', async (e) => {
    const files = Array.from(e.target.files);
    if (files.length < 2) {
        showToast('Please select at least 2 PDFs to merge', 'error');
        mergePdfInput.value = '';
        return;
    }

    try {
        showToast('Loading PDFs...', 'info');
        
        mergeFiles = [];
        for (const file of files) {
            const arrayBuffer = await file.arrayBuffer();
            const bytes = new Uint8Array(arrayBuffer);
            const pdf = await PDFDocument.load(bytes, { ignoreEncryption: true });
            
            mergeFiles.push({
                file: file,
                name: file.name,
                pageCount: pdf.getPageCount(),
                bytes: bytes
            });
        }

        renderMergeFileList();
        mergeModal.classList.remove('hidden');

    } catch (error) {
        showToast('Error loading PDFs: ' + error.message, 'error');
        console.error(error);
    }

    mergePdfInput.value = '';
});

function renderMergeFileList() {
    if (mergeFiles.length === 0) {
        mergeFileList.innerHTML = `
            <div class="empty-merge-list">
                <p>No files to merge</p>
            </div>
        `;
        return;
    }

    mergeFileList.innerHTML = '';
    
    mergeFiles.forEach((fileData, index) => {
        const div = document.createElement('div');
        div.className = 'merge-file-item';
        div.draggable = true;
        div.dataset.index = index;
        
        div.innerHTML = `
            <span class="drag-handle">‚ãÆ‚ãÆ</span>
            <div class="file-order">${index + 1}</div>
            <div class="file-info">
                <div class="file-name" title="${fileData.name}">${fileData.name}</div>
                <div class="file-pages">${fileData.pageCount} pages</div>
            </div>
            <button class="remove-file" data-index="${index}">Remove</button>
        `;
        
        mergeFileList.appendChild(div);
    });

    const items = mergeFileList.querySelectorAll('.merge-file-item');
    items.forEach(item => {
        item.addEventListener('dragstart', handleDragStart);
        item.addEventListener('dragover', handleDragOver);
        item.addEventListener('drop', handleDrop);
        item.addEventListener('dragend', handleDragEnd);
        item.addEventListener('dragenter', handleDragEnter);
        item.addEventListener('dragleave', handleDragLeave);
    });

    mergeFileList.querySelectorAll('.remove-file').forEach(btn => {
        btn.addEventListener('click', (e) => {
            e.stopPropagation();
            const index = parseInt(e.target.dataset.index);
            mergeFiles.splice(index, 1);
            renderMergeFileList();
            
            if (mergeFiles.length < 2) {
                showToast('Need at least 2 PDFs to merge', 'error');
                if (mergeFiles.length === 0) {
                    closeModal();
                }
            }
        });
    });
}

function handleDragStart(e) {
    draggedElement = this;
    this.classList.add('dragging');
    e.dataTransfer.effectAllowed = 'move';
    e.dataTransfer.setData('text/html', this.innerHTML);
}

function handleDragOver(e) {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';
    return false;
}

function handleDragEnter(e) {
    if (this !== draggedElement) {
        this.classList.add('drag-over');
    }
}

function handleDragLeave(e) {
    this.classList.remove('drag-over');
}

function handleDrop(e) {
    e.stopPropagation();
    e.preventDefault();

    if (draggedElement !== this) {
        const fromIndex = parseInt(draggedElement.dataset.index);
        const toIndex = parseInt(this.dataset.index);

        const movedItem = mergeFiles.splice(fromIndex, 1)[0];
        mergeFiles.splice(toIndex, 0, movedItem);

        renderMergeFileList();
    }

    return false;
}

function handleDragEnd(e) {
    const items = mergeFileList.querySelectorAll('.merge-file-item');
    items.forEach(item => {
        item.classList.remove('dragging');
        item.classList.remove('drag-over');
    });
}

confirmMergeBtn.addEventListener('click', async () => {
    if (mergeFiles.length < 2) {
        showToast('Need at least 2 PDFs to merge', 'error');
        return;
    }

    try {
        closeModal();
        showToast('Merging PDFs...', 'info');

        const mergedPdf = await PDFDocument.create();
        const allBookmarks = [];
        let currentPageOffset = 0;

        for (let i = 0; i < mergeFiles.length; i++) {
            const fileData = mergeFiles[i];
            
            showToast(`Processing ${i + 1}/${mergeFiles.length}: ${fileData.name}`, 'info');
            
            const sourcePdf = await PDFDocument.load(fileData.bytes, { ignoreEncryption: true });
            
            
            const existingBookmarks = await extractExistingBookmarks(sourcePdf);
            
            existingBookmarks.forEach(bookmark => {
                allBookmarks.push({
                    ...bookmark,
                    page: bookmark.page + currentPageOffset,
                    id: Date.now() + Math.random()
                });
            });
            
            const pageIndices = sourcePdf.getPageIndices();
            const copiedPages = await mergedPdf.copyPages(sourcePdf, pageIndices);
            
            copiedPages.forEach((page) => {
                mergedPdf.addPage(page);
            });
            
            currentPageOffset += sourcePdf.getPageCount();
        }

        showToast('Saving merged PDF...', 'info');

        if (allBookmarks.length > 0) {
            showToast('Adding bookmarks to merged PDF...', 'info');
            
            const context = mergedPdf.context;
            const outlinesRef = context.nextRef();
            const outlines = context.obj({
                Type: 'Outlines',
            });

            const itemRefs = [];
            const items = [];

            allBookmarks.forEach((bookmark) => {
                const page = mergedPdf.getPage(bookmark.page - 1);
                const itemRef = context.nextRef();
                itemRefs.push(itemRef);

                const item = {
                    Title: PDFString.of(cleanBookmarkTitle(bookmark.title)),
                    Parent: outlinesRef,
                    Dest: [
                        page.ref,
                        'XYZ',
                        null,
                        null,
                        null
                    ]
                };

                items.push(item);
            });

            items.forEach((item, index) => {
                if (index > 0) {
                    item.Prev = itemRefs[index - 1];
                }
                if (index < items.length - 1) {
                    item.Next = itemRefs[index + 1];
                }
            });

            items.forEach((item, index) => {
                context.assign(itemRefs[index], context.obj(item));
            });

            if (itemRefs.length > 0) {
                outlines.set(PDFName.of('First'), itemRefs[0]);
                outlines.set(PDFName.of('Last'), itemRefs[itemRefs.length - 1]);
                outlines.set(PDFName.of('Count'), PDFNumber.of(itemRefs.length));
            }

            context.assign(outlinesRef, outlines);
            mergedPdf.catalog.set(PDFName.of('Outlines'), outlinesRef);
        }

        const mergedPdfBytes = await mergedPdf.save();

        const blob = new Blob([mergedPdfBytes], { type: 'application/pdf' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'merged.pdf';
        a.click();
        URL.revokeObjectURL(url);

        const totalPages = mergedPdf.getPageCount();
        const bookmarkMsg = allBookmarks.length > 0 ? ` with ${allBookmarks.length} bookmarks` : '';
        showToast(`Successfully merged ${mergeFiles.length} PDFs (${totalPages} pages${bookmarkMsg})!`, 'success');

        mergeFiles = [];

    } catch (error) {
        showToast('Error merging PDFs: ' + error.message, 'error');
        console.error('Merge error details:', error);
    }
});

function closeModal() {
    mergeModal.classList.add('hidden');
}

cancelMergeBtn.addEventListener('click', () => {
    mergeFiles = [];
    closeModal();
});

closeMergeModalBtn.addEventListener('click', () => {
    mergeFiles = [];
    closeModal();
});

mergeModal.addEventListener('click', (e) => {
    if (e.target === mergeModal) {
        mergeFiles = [];
        closeModal();
    }
});

async function loadPdfFile(file) {
    try {
        originalFile = file;
        pdfFileName = file.name;
        const arrayBuffer = await file.arrayBuffer();
        pdfBytes = new Uint8Array(arrayBuffer);
        
        pdfDoc = await PDFDocument.load(pdfBytes, { ignoreEncryption: true });
        
        const loadingTask = pdfjsLib.getDocument({ data: pdfBytes });
        pdfJsDoc = await loadingTask.promise;
        totalPages = pdfJsDoc.numPages;
        
        pdfName.textContent = file.name;
        applyBookmarksBtn.disabled = false;
        openPageEditorBtn.disabled = false;
        
        const loadExistingBtn = document.getElementById('loadExistingBtn');
        loadExistingBtn.disabled = false;
        
        await renderAllPages();
        
        renderBookmarks();
        
        showToast('PDF loaded successfully', 'success');
    } catch (error) {
        showToast('Error loading PDF: ' + error.message, 'error');
        console.error(error);
    }
}

function showToast(message, type = 'info') {
    const toast = document.getElementById('toast');
    
    if (toastTimeout) {
        clearTimeout(toastTimeout);
    }
    
    toast.classList.remove('show');
    
    setTimeout(() => {
        toast.textContent = message;
        toast.className = `toast ${type}`;
        toast.classList.add('show');
        
        toastTimeout = setTimeout(() => {
            toast.classList.remove('show');
            toastTimeout = null;
        }, 3000);
    }, 50);
}

function toTitleCase(str) {
    const smallWords = ['the', 'and', 'of', 'in', 'on', 'at', 'by', 'to', 'for', 
                        'with', 'from', 'or', 'a', 'an', 'but', 'nor', 'as', 'if'];
    
    const words = str.toLowerCase().split(' ');
    let firstWordIdx = 0;
    
    if (words[0].match(/^\d+[.\)]?$/) && words.length > 1) {
        firstWordIdx = 1;
    }
    
    for (let i = 0; i < words.length; i++) {
        const word = words[i];
        
        const previousWordEndsWithColon = i > 0 && words[i - 1].endsWith(':');
        
        if (i === firstWordIdx || i === words.length - 1 || previousWordEndsWithColon || !smallWords.includes(word)) {
            words[i] = word.charAt(0).toUpperCase() + word.slice(1);
        }
    }
    
    return words.join(' ');
}

async function extractExistingBookmarks(pdfLibDoc) {
    try {
        const catalog = pdfLibDoc.catalog;
        const outlinesRef = catalog.lookup(PDFName.of('Outlines'));
        
        if (!outlinesRef) {
            return [];
        }

        const existingBookmarks = [];
        const pages = pdfLibDoc.getPages();
        
        const pageRefToNum = new Map();
        pages.forEach((page, index) => {
            const refStr = page.ref.toString();
            pageRefToNum.set(refStr, index + 1);
        });
        
        const firstItemRef = outlinesRef.get(PDFName.of('First'));
        
        if (!firstItemRef) {
            return [];
        }
        
        function traverseOutline(itemRef, level = 1) {
            if (!itemRef) return;
            
            const item = pdfLibDoc.context.lookup(itemRef);
            if (!item) return;

            const titleObj = item.get(PDFName.of('Title'));
            
            if (!titleObj) {
                const nextRef = item.get(PDFName.of('Next'));
                if (nextRef) traverseOutline(nextRef, level);
                return;
            }
            
            const title = titleObj.decodeText ? titleObj.decodeText() : titleObj.toString();
            
            let pageNum = 1;
            const destObj = item.get(PDFName.of('Dest'));
            
            if (destObj) {
                try {
                    let destArray = destObj;
                    
                    if (destArray.array && destArray.array.length > 0) {
                        const pageRefObj = destArray.array[0];
                        
                        let pageRefStr;
                        if (pageRefObj && pageRefObj.toString) {
                            pageRefStr = pageRefObj.toString();
                        } else if (typeof pageRefObj === 'object' && pageRefObj.objectNumber !== undefined) {
                            pageRefStr = `${pageRefObj.objectNumber} ${pageRefObj.generationNumber} R`;
                        }
                        
                        if (pageRefStr && pageRefToNum.has(pageRefStr)) {
                            pageNum = pageRefToNum.get(pageRefStr);
                        }
                    }
                } catch (e) {
                    console.warn('Error extracting page number for bookmark:', title, e);
                }
            }

            existingBookmarks.push({
                id: Date.now() + Math.random(),
                title: title,
                page: pageNum,
                level: Math.min(level, 3)
            });

            const firstRef = item.get(PDFName.of('First'));
            if (firstRef) {
                traverseOutline(firstRef, level + 1);
            }

            const nextRef = item.get(PDFName.of('Next'));
            if (nextRef) {
                traverseOutline(nextRef, level);
            }
        }

        traverseOutline(firstItemRef, 1);

        return existingBookmarks;
        
    } catch (error) {
        console.warn('Could not extract bookmarks:', error);
        return [];
    }
}

async function renderAllPages() {
    if (!pdfJsDoc) return;

    pdfViewerContainer.innerHTML = '';
    loadingEl.classList.add('hidden');
    pageCache.clear();
    visiblePages.clear();

    const scale = 1.5;

    for (let pageNumber = 1; pageNumber <= totalPages; pageNumber++) {
        const page = await pdfJsDoc.getPage(pageNumber);
        const viewport = page.getViewport({ scale: scale });

        const pageContainer = document.createElement('div');
        pageContainer.className = 'pdf-page-container';
        pageContainer.dataset.pageNumber = pageNumber;
        pageContainer.style.minHeight = viewport.height + 'px';
        pageContainer.style.width = viewport.width + 'px';
        pageContainer.style.marginBottom = '20px';
        pageContainer.style.position = 'relative';
        pageContainer.style.background = '#1a1a1a';

        pdfViewerContainer.appendChild(pageContainer);
    }

    for (let i = 1; i <= Math.min(INITIAL_PAGES_TO_LOAD, totalPages); i++) {
        await renderPage(i, scale);
    }

    setupLazyLoading(scale);
    
    updateCurrentPage();
    
    pdfViewerContainer.removeEventListener('scroll', updateCurrentPage);
    pdfViewerContainer.addEventListener('scroll', updateCurrentPage);
}

async function renderPage(pageNumber, scale) {
    if (pageCache.has(pageNumber)) {
        return;
    }

    const pageContainer = document.querySelector(`.pdf-page-container[data-page-number="${pageNumber}"]`);
    if (!pageContainer) return;

    try {
        const page = await pdfJsDoc.getPage(pageNumber);
        const viewport = page.getViewport({ scale: scale });

        pageContainer.innerHTML = '';

        const canvas = document.createElement('canvas');
        canvas.className = 'pdf-page';
        const context = canvas.getContext('2d');
        canvas.height = viewport.height;
        canvas.width = viewport.width;

        const textLayerDiv = document.createElement('div');
        textLayerDiv.className = 'textLayer';
        textLayerDiv.style.width = viewport.width + 'px';
        textLayerDiv.style.height = viewport.height + 'px';
        textLayerDiv.style.setProperty('--scale-factor', scale);

        pageContainer.appendChild(canvas);
        pageContainer.appendChild(textLayerDiv);

        await page.render({
            canvasContext: context,
            viewport: viewport
        }).promise;

        const textContent = await page.getTextContent();
        pdfjsLib.renderTextLayer({
            textContentSource: textContent,
            container: textLayerDiv,
            viewport: viewport,
            textDivs: []
        });

        pageCache.set(pageNumber, true);
        visiblePages.add(pageNumber);

    } catch (error) {
        console.error(`Error rendering page ${pageNumber}:`, error);
    }
}

function unrenderPage(pageNumber) {
    const pageContainer = document.querySelector(`.pdf-page-container[data-page-number="${pageNumber}"]`);
    if (!pageContainer) return;

    const canvas = pageContainer.querySelector('canvas');
    const textLayer = pageContainer.querySelector('.textLayer');
    
    if (canvas) canvas.remove();
    if (textLayer) textLayer.remove();

    pageCache.delete(pageNumber);
    visiblePages.delete(pageNumber);
}

function setupLazyLoading(scale) {
    const observerOptions = {
        root: pdfViewerContainer,
        rootMargin: '500px',
        threshold: 0
    };

    const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
            const pageNumber = parseInt(entry.target.dataset.pageNumber);

            if (entry.isIntersecting) {
                renderPage(pageNumber, scale);
                
                for (let i = 1; i <= PAGES_TO_RENDER_AHEAD; i++) {
                    if (pageNumber + i <= totalPages) {
                        renderPage(pageNumber + i, scale);
                    }
                    if (pageNumber - i >= 1) {
                        renderPage(pageNumber - i, scale);
                    }
                }
            } else {
                const currentPage = getCurrentVisiblePage();
                const distance = Math.abs(pageNumber - currentPage);
                
                if (distance > PAGES_TO_RENDER_AHEAD + 3) {
                    unrenderPage(pageNumber);
                }
            }
        });
    }, observerOptions);

    document.querySelectorAll('.pdf-page-container').forEach(container => {
        observer.observe(container);
    });
}

function getCurrentVisiblePage() {
    const container = pdfViewerContainer;
    const containerRect = container.getBoundingClientRect();
    const centerY = containerRect.top + containerRect.height / 2;

    let currentPageNum = 1;
    const pages = document.querySelectorAll('.pdf-page-container');
    
    pages.forEach(page => {
        const rect = page.getBoundingClientRect();
        if (rect.top <= centerY && rect.bottom >= centerY) {
            currentPageNum = parseInt(page.dataset.pageNumber);
        }
    });

    return currentPageNum;
}

function updateCurrentPage() {
    currentPage = getCurrentVisiblePage();
    
    const pageDisplay = document.getElementById('currentPageDisplay');
    if (pageDisplay) {
        pageDisplay.innerHTML = `Page ${currentPage}<br>of ${totalPages}`;
    }
}

function getPageFromSelection() {
    const selection = window.getSelection();
    if (!selection.rangeCount) return currentPage;

    const range = selection.getRangeAt(0);
    const container = range.startContainer;

    let element = container.parentElement;
    while (element) {
        if (element.classList && element.classList.contains('pdf-page-container')) {
            return parseInt(element.dataset.pageNumber);
        }
        element = element.parentElement;
    }

    return currentPage;
}

document.getElementById('selectInvertPages').addEventListener('click', () => {
    const newSelection = new Set();
    
    pageEditorState.reorderedPages.forEach((page, index) => {
        if (!page.deleted && !pageEditorState.selectedPages.has(index)) {
            newSelection.add(index);
        }
    });
    
    pageEditorState.selectedPages = newSelection;
    syncCheckboxes();
    updateSelectionInfo();
});

pdfInput.addEventListener('change', async (e) => {
    const file = e.target.files[0];
    if (!file) return;
    
    await loadPdfFile(file);
});

const loadExistingBtn = document.getElementById('loadExistingBtn');

loadExistingBtn.addEventListener('click', async () => {
    if (!pdfDoc) {
        showToast('No PDF loaded', 'error');
        return;
    }

    try {
        const existingBookmarks = await extractExistingBookmarks(pdfDoc);
        
        if (existingBookmarks.length === 0) {
            showToast('No existing bookmarks found in PDF', 'info');
            return;
        }
        
        const shouldReplace = confirm(
            `Found ${existingBookmarks.length} existing bookmarks.\n\n` +
            `Click OK to REPLACE current bookmarks (${bookmarks.length})\n` +
            `Click Cancel to MERGE with current bookmarks`
        );
        
        if (shouldReplace) {
            bookmarks = existingBookmarks;
            showToast(`Loaded ${existingBookmarks.length} bookmarks`, 'success');
        } else {
            let addedCount = 0;
            existingBookmarks.forEach(existing => {
                const duplicate = bookmarks.find(b => 
                    b.page === existing.page && b.title === existing.title
                );
                if (!duplicate) {
                    bookmarks.push(existing);
                    addedCount++;
                }
            });
            bookmarks.sort((a, b) => a.page - b.page);
            const skipped = existingBookmarks.length - addedCount;
            showToast(`Merged ${addedCount} bookmarks${skipped > 0 ? ` (${skipped} duplicates skipped)` : ''}`, 'success');
        }
        
        renderBookmarks();
        
    } catch (error) {
        showToast('Error loading bookmarks: ' + error.message, 'error');
        console.error(error);
    }
});

function cleanBookmarkTitle(title) {
    return title
        .replace(/‚ûù|‚Üí|‚ûî|‚ûû|‚ûü|‚û†|‚û°|‚û¢|‚û£|‚û§|‚û•|‚û¶|‚ûß|‚û®/g, '->') 
        .replace(/≈°/g, 's')
        .replace(/≈æ/g, 'z')
        .replace(/['']/g, "'")
        .replace(/[""]/g, '"')
        .replace(/[‚Äî‚Äì]/g, '-')
        .replace(/‚Ä¶/g, '...')
        .replace(/[\u2000-\u206F]/g, ' ')  // General punctuation spaces
        .replace(/[\u2190-\u21FF]/g, '->')  // All arrow characters
        .replace(/[^\x00-\x7F]/g, (char) => {
            // For any remaining non-ASCII, try to keep if it's common
            const code = char.charCodeAt(0);
            if (code < 256) return char;  // Keep Latin-1 supplement
            return ''; 
        })
        .replace(/\s+/g, ' ')
        .trim();
}

function addBookmark(level = 1) {
    let title = '';
    let selectedText = window.getSelection().toString().trim();
    
    if (selectedText) {
        title = selectedText.replace(/\n+/g, ' ').replace(/\s+/g, ' ').trim();
        if (title.length > 100) {
            title = title.substring(0, 100);
        }
        title = cleanBookmarkTitle(title);
    } else {
        const labels = { 1: 'Chapter', 2: 'Section', 3: 'Subsection' };
        title = labels[level];
    }

    const pageNumber = getPageFromSelection();

    const bookmark = {
        id: Date.now() + Math.random(),
        title: title,
        page: pageNumber,
        level: level
    };
    
    bookmarks.push(bookmark);
    
    bookmarks.sort((a, b) => a.page - b.page);
    
    renderBookmarks();
    
    scrollToBookmark(bookmark.id);
    
    showToast(`Added ${level === 1 ? 'Chapter' : level === 2 ? 'Section' : 'Subsection'} on page ${pageNumber}`, 'success');
}

function scrollToBookmark(bookmarkId) {
    setTimeout(() => {
        const bookmarkElements = bookmarksList.querySelectorAll('.bookmark-item');
        
        bookmarkElements.forEach(el => {
            const input = el.querySelector('input[data-id]');
            if (input && parseFloat(input.dataset.id) === bookmarkId) {
                el.scrollIntoView({ 
                    behavior: 'smooth', 
                    block: 'center' 
                });
                
                el.classList.add('newly-added');
                setTimeout(() => {
                    el.classList.remove('newly-added');
                }, 600);
            }
        });
    }, 100);
}

document.addEventListener('keydown', (e) => {
    const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
    const modifier = isMac ? e.metaKey : e.ctrlKey;

    if (modifier && e.key === 'a') {
        e.preventDefault();
        addBookmark(1);
    } else if (modifier && e.key === 's') {
        e.preventDefault();
        addBookmark(2);
    } else if (modifier && e.key === 'd') {
        e.preventDefault();
        addBookmark(3);
    }
});

function deleteBookmark(id) {
    bookmarks = bookmarks.filter(b => b.id !== id);
    renderBookmarks();
}

function titleCaseBookmark(id) {
    const bookmark = bookmarks.find(b => b.id === id);
    if (!bookmark || !bookmark.title) return;
    
    if (lastTitleCaseOperation && 
        lastTitleCaseOperation.id === id && 
        bookmark.title === lastTitleCaseOperation.newTitle) {
        bookmark.title = lastTitleCaseOperation.oldTitle;
        lastTitleCaseOperation = null;
        showToast('Title case undone', 'info');
    } else {
        const oldTitle = bookmark.title;
        const newTitle = toTitleCase(bookmark.title);
        bookmark.title = newTitle;
        
        lastTitleCaseOperation = {
            id: id,
            oldTitle: oldTitle,
            newTitle: newTitle
        };
        
        showToast('Title case applied', 'success');
    }
    
    renderBookmarks();
}

function scrollToPage(pageNumber) {
    const pageContainer = document.querySelector(`.pdf-page-container[data-page-number="${pageNumber}"]`);
    if (pageContainer) {
        pageContainer.scrollIntoView({ 
            behavior: 'smooth', 
            block: 'start' 
        });
        
        currentPage = pageNumber;
        updateCurrentPage();
        
        pageContainer.style.outline = '3px solid rgba(102, 126, 234, 0.6)';
        setTimeout(() => {
            pageContainer.style.outline = '';
        }, 1000);
        
        showToast(`Navigated to page ${pageNumber}`, 'info');
    }
}

function renderBookmarks() {
    if (bookmarks.length === 0) {
        bookmarksList.innerHTML = `
            <div class="empty-state">
                <p>üìë No bookmarks yet</p>
                <p style="margin-top: 10px; font-size: 13px;">
                    Select text in PDF and use keyboard shortcuts
                </p>
            </div>
        `;
        return;
    }

    bookmarks.sort((a, b) => a.page - b.page);

    bookmarksList.innerHTML = '';
    
    bookmarks.forEach(bookmark => {
        const div = document.createElement('div');
        div.className = `bookmark-item level-${bookmark.level}`;
        
        const levelLabels = { 1: 'Chapter', 2: 'Section', 3: 'Subsection' };
        
        div.innerHTML = `
            <div class="bookmark-item-header">
                <div class="bookmark-header-left">
                    <span class="bookmark-page clickable" data-page="${bookmark.page}">Page ${bookmark.page}</span>
                    <span style="color: #888; font-size: 12px;">${levelLabels[bookmark.level]}</span>
                </div>
                <div class="bookmark-actions">
                    <button class="btn btn-secondary btn-small ${lastTitleCaseOperation && lastTitleCaseOperation.id === bookmark.id ? 'undo-available' : ''}" data-id="${bookmark.id}" data-action="titlecase" title="${lastTitleCaseOperation && lastTitleCaseOperation.id === bookmark.id ? 'Click to undo' : 'Apply title case'}">Aa</button>
                    <button class="btn btn-delete btn-small" data-id="${bookmark.id}" data-action="delete">üóëÔ∏è</button>
                </div>
            </div>
            <input 
                type="text" 
                placeholder="Bookmark title" 
                value="${bookmark.title}"
                data-id="${bookmark.id}"
                data-field="title"
            />
        `;
        
        bookmarksList.appendChild(div);
    });
    
    bookmarksList.querySelectorAll('.bookmark-page.clickable').forEach(pageEl => {
        pageEl.addEventListener('click', (e) => {
            const pageNumber = parseInt(e.target.dataset.page);
            scrollToPage(pageNumber);
        });
    });
    
    bookmarksList.querySelectorAll('input').forEach(input => {
        input.addEventListener('input', (e) => {
            const id = parseFloat(e.target.dataset.id);
            const bookmark = bookmarks.find(b => b.id === id);
            if (bookmark) {
                bookmark.title = e.target.value;
                
                if (lastTitleCaseOperation && lastTitleCaseOperation.id === id) {
                    lastTitleCaseOperation = null;
                }
            }
        });
    });
    
    bookmarksList.querySelectorAll('button[data-action]').forEach(btn => {
        btn.addEventListener('click', (e) => {
            const id = parseFloat(e.target.dataset.id);
            const action = e.target.dataset.action;
            
            if (action === 'delete') {
                deleteBookmark(id);
            } else if (action === 'titlecase') {
                titleCaseBookmark(id);
            }
        });
    });
}

importInput.addEventListener('change', async (e) => {
    const file = e.target.files[0];
    if (!file) return;

    try {
        const text = await file.text();
        const lines = text.split('\n');
        
        bookmarks = [];
        
        lines.forEach(line => {
            line = line.trim();
            if (!line) return;
            
            const match = line.match(/"([^"]+)"\s+(\d+)\s+(\d+)/);
            if (match) {
                bookmarks.push({
                    id: Date.now() + Math.random(),
                    title: match[1],
                    page: parseInt(match[2]),
                    level: parseInt(match[3])
                });
            }
        });
        
        renderBookmarks();
        showToast(`Imported ${bookmarks.length} bookmarks`, 'success');
    } catch (error) {
        showToast('Error importing bookmarks: ' + error.message, 'error');
        console.error(error);
    }

    importInput.value = '';
});

exportBtn.addEventListener('click', () => {
    if (bookmarks.length === 0) {
        showToast('No bookmarks to export', 'error');
        return;
    }

    const content = bookmarks
        .map(b => `"${b.title}" ${b.page} ${b.level}`)
        .join('\n');
    
    const blob = new Blob([content], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'bookmarks.txt';
    a.click();
    URL.revokeObjectURL(url);
    
    showToast('Bookmarks exported', 'success');
});

applyBookmarksBtn.addEventListener('click', async () => {
    if (!originalFile) {
        showToast('No PDF loaded', 'error');
        return;
    }

    if (bookmarks.length === 0) {
        showToast('No bookmarks to apply', 'error');
        return;
    }

    try {
        showToast('Creating PDF with bookmarks...', 'info');

        const freshArrayBuffer = await originalFile.arrayBuffer();
        const freshPdfBytes = new Uint8Array(freshArrayBuffer);
        const newPdfDoc = await PDFDocument.load(freshPdfBytes, { ignoreEncryption: true });
        

        let maxLevel = 1;
        for (let bookmark of bookmarks) {
            bookmark.title = cleanBookmarkTitle(bookmark.title);
            
            if (bookmark.level > maxLevel + 1) {
                bookmark.level = maxLevel + 1;
            }
            maxLevel = Math.max(maxLevel, bookmark.level);
        }

        const sortedBookmarks = [...bookmarks].sort((a, b) => a.page - b.page);

        const context = newPdfDoc.context;
        const outlinesRef = context.nextRef();
        const outlines = context.obj({
            Type: 'Outlines',
        });

        const itemRefs = [];
        const items = [];

        sortedBookmarks.forEach((bookmark) => {
            const page = newPdfDoc.getPage(bookmark.page - 1);
            const itemRef = context.nextRef();
            itemRefs.push(itemRef);

            const item = {
                Title: PDFString.of(bookmark.title),
                Parent: outlinesRef,
                Dest: [
                    page.ref,
                    'XYZ',
                    null,
                    null,
                    null
                ]
            };

            items.push(item);
        });

        items.forEach((item, index) => {
            if (index > 0) {
                item.Prev = itemRefs[index - 1];
            }
            if (index < items.length - 1) {
                item.Next = itemRefs[index + 1];
            }
        });

        items.forEach((item, index) => {
            context.assign(itemRefs[index], context.obj(item));
        });

        if (itemRefs.length > 0) {
            outlines.set(PDFName.of('First'), itemRefs[0]);
            outlines.set(PDFName.of('Last'), itemRefs[itemRefs.length - 1]);
            outlines.set(PDFName.of('Count'), PDFNumber.of(itemRefs.length));
        }

        context.assign(outlinesRef, outlines);
        newPdfDoc.catalog.set(PDFName.of('Outlines'), outlinesRef);

        const pdfBytesWithBookmarks = await newPdfDoc.save();

        const blob = new Blob([pdfBytesWithBookmarks], { type: 'application/pdf' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = pdfFileName.replace('.pdf', '_bookmarked.pdf');
        a.click();
        URL.revokeObjectURL(url);

        showToast('PDF with bookmarks created successfully!', 'success');

    } catch (error) {
        showToast('Error creating PDF: ' + error.message, 'error');
        console.error('Full error:', error);
    }
});

renderBookmarks();

let pageEditorState = {
    pages: [],
    selectedPages: new Set(),
    rotations: new Map(),
    deletedPages: new Set(),
    reorderedPages: []
};

const openPageEditorBtn = document.getElementById('openPageEditor');
const pageEditorModal = document.getElementById('pageEditorModal');
const closePageEditorBtn = document.getElementById('closePageEditor');
const pageGrid = document.getElementById('pageGrid');
const selectionCount = document.getElementById('selectionCount');

openPageEditorBtn.addEventListener('click', async () => {
    if (!pdfDoc || !pdfJsDoc) {
        showToast('No PDF loaded', 'error');
        return;
    }

    showToast('Loading page editor...', 'info');
    
    pageEditorState = {
        pages: [],
        selectedPages: new Set(),
        rotations: new Map(),
        deletedPages: new Set(),
        reorderedPages: []
    };
    
    undoStack = [];
    updateUndoButton();

    for (let i = 1; i <= totalPages; i++) {
        pageEditorState.pages.push({
            number: i,
            rotation: 0,
            deleted: false
        });
    }

    pageEditorState.reorderedPages = [...pageEditorState.pages];

    await renderPageGrid();
    pageEditorModal.classList.remove('hidden');
    updateSelectionInfo();
});

closePageEditorBtn.addEventListener('click', () => {
    pageEditorModal.classList.add('hidden');
});

document.getElementById('cancelPageEdit').addEventListener('click', () => {
    pageEditorModal.classList.add('hidden');
});

async function renderPageGrid() {
    pageGrid.innerHTML = '<div style="grid-column: 1/-1; text-align: center; padding: 40px; color: #888;">Loading thumbnails...</div>';

    const thumbnails = [];

    for (let i = 0; i < pageEditorState.reorderedPages.length; i++) {
        const pageData = pageEditorState.reorderedPages[i];
        if (pageData.deleted) continue;

        const page = await pdfJsDoc.getPage(pageData.number);
        const scale = 0.5;
        const viewport = page.getViewport({ scale, rotation: pageData.rotation });

        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        canvas.height = viewport.height;
        canvas.width = viewport.width;

        await page.render({
            canvasContext: context,
            viewport: viewport
        }).promise;

        thumbnails.push({
            canvas,
            pageData,
            index: i,
            viewport
        });
    }

    pageGrid.innerHTML = '';

    thumbnails.forEach(({ canvas, pageData, index, viewport }) => {
        const div = document.createElement('div');
        div.className = pageData.deleted ? 'page-thumbnail deleted' : 'page-thumbnail';
        div.dataset.index = index;
        div.draggable = !pageData.deleted;
    
        const rotation = pageData.rotation !== 0 ? `<span class="rotation-indicator">${pageData.rotation}¬∞</span>` : '';
        
        const actualWidth = Math.round(viewport.width * 2);
        const actualHeight = Math.round(viewport.height * 2);
        
        div.innerHTML = `
            <input type="checkbox" class="page-checkbox" data-index="${index}" ${pageData.deleted ? 'disabled' : ''}>
            ${rotation}
            <canvas class="page-thumbnail-canvas"></canvas>
            <div class="page-thumbnail-info">
                <span class="page-number">Page ${pageData.number}</span>
                <span class="page-size">${actualWidth} √ó ${actualHeight}</span>
            </div>
        `;
    
        const thumbnailCanvas = div.querySelector('.page-thumbnail-canvas');
        const ctx = thumbnailCanvas.getContext('2d');
        thumbnailCanvas.width = canvas.width;
        thumbnailCanvas.height = canvas.height;
        ctx.drawImage(canvas, 0, 0);
    
        pageGrid.appendChild(div);
    });

    setupPageGridEvents();
}

function setupPageGridEvents() {
    pageGrid.querySelectorAll('.page-checkbox').forEach(checkbox => {
        checkbox.addEventListener('change', (e) => {
            const index = parseInt(e.target.dataset.index);
            if (e.target.checked) {
                pageEditorState.selectedPages.add(index);
                e.target.closest('.page-thumbnail').classList.add('selected');
            } else {
                pageEditorState.selectedPages.delete(index);
                e.target.closest('.page-thumbnail').classList.remove('selected');
            }
            updateSelectionInfo();
        });
    });

    pageGrid.querySelectorAll('.page-thumbnail').forEach(thumb => {
        thumb.addEventListener('click', (e) => {
            if (e.target.classList.contains('page-checkbox')) return;
            const checkbox = thumb.querySelector('.page-checkbox');
            checkbox.checked = !checkbox.checked;
            checkbox.dispatchEvent(new Event('change'));
        });
    });

    const thumbnails = pageGrid.querySelectorAll('.page-thumbnail');
    thumbnails.forEach(thumb => {
        thumb.addEventListener('dragstart', handlePageDragStart);
        thumb.addEventListener('dragover', handlePageDragOver);
        thumb.addEventListener('drop', handlePageDrop);
        thumb.addEventListener('dragend', handlePageDragEnd);
        thumb.addEventListener('dragenter', handlePageDragEnter);
        thumb.addEventListener('dragleave', handlePageDragLeave);
    });
}

let draggedPageElement = null;

function handlePageDragStart(e) {
    draggedPageElement = this;
    this.classList.add('dragging');
    e.dataTransfer.effectAllowed = 'move';
}

function handlePageDragOver(e) {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';
    return false;
}

function handlePageDragEnter(e) {
    if (this !== draggedPageElement) {
        this.classList.add('drag-over');
    }
}

function handlePageDragLeave(e) {
    this.classList.remove('drag-over');
}

function handlePageDrop(e) {
    e.stopPropagation();
    e.preventDefault();

    if (draggedPageElement !== this) {
        const fromIndex = parseInt(draggedPageElement.dataset.index);
        const toIndex = parseInt(this.dataset.index);

        saveUndoState('Reorder Pages');

        const container = document.getElementById('pageGridContainer');
        const scrollPos = container.scrollTop;

        const movedPage = pageEditorState.reorderedPages.splice(fromIndex, 1)[0];
        pageEditorState.reorderedPages.splice(toIndex, 0, movedPage);

        const fromElement = pageGrid.querySelector(`[data-index="${fromIndex}"]`);
        const toElement = pageGrid.querySelector(`[data-index="${toIndex}"]`);
        
        if (fromIndex < toIndex) {
            toElement.parentNode.insertBefore(fromElement, toElement.nextSibling);
        } else {
            toElement.parentNode.insertBefore(fromElement, toElement);
        }

        const thumbnails = pageGrid.querySelectorAll('.page-thumbnail');
        thumbnails.forEach((thumb, newIndex) => {
            thumb.dataset.index = newIndex;
            const checkbox = thumb.querySelector('.page-checkbox');
            if (checkbox) {
                checkbox.dataset.index = newIndex;
            }
        });

        const newSelectedPages = new Set();
        pageEditorState.selectedPages.forEach(oldIndex => {
            if (oldIndex === fromIndex) {
                newSelectedPages.add(toIndex);
            } else if (fromIndex < toIndex) {
                if (oldIndex > fromIndex && oldIndex <= toIndex) {
                    newSelectedPages.add(oldIndex - 1);
                } else {
                    newSelectedPages.add(oldIndex);
                }
            } else {
                if (oldIndex >= toIndex && oldIndex < fromIndex) {
                    newSelectedPages.add(oldIndex + 1);
                } else {
                    newSelectedPages.add(oldIndex);
                }
            }
        });
        pageEditorState.selectedPages = newSelectedPages;

        container.scrollTop = scrollPos;
        syncCheckboxes();
    }

    return false;
}

function handlePageDragEnd(e) {
    pageGrid.querySelectorAll('.page-thumbnail').forEach(thumb => {
        thumb.classList.remove('dragging');
        thumb.classList.remove('drag-over');
    });
}

document.getElementById('selectAllPages').addEventListener('click', () => {
    pageEditorState.selectedPages.clear();
    pageEditorState.reorderedPages.forEach((_, index) => {
        pageEditorState.selectedPages.add(index);
    });
    pageGrid.querySelectorAll('.page-checkbox').forEach(cb => {
        cb.checked = true;
        cb.closest('.page-thumbnail').classList.add('selected');
    });
    updateSelectionInfo();
});

document.getElementById('selectNonePages').addEventListener('click', () => {
    pageEditorState.selectedPages.clear();
    pageGrid.querySelectorAll('.page-checkbox').forEach(cb => {
        cb.checked = false;
        cb.closest('.page-thumbnail').classList.remove('selected');
    });
    updateSelectionInfo();
});

document.getElementById('selectEvenPages').addEventListener('click', () => {
    pageEditorState.selectedPages.clear();
    pageEditorState.reorderedPages.forEach((page, index) => {
        if (page.number % 2 === 0) {
            pageEditorState.selectedPages.add(index);
        }
    });
    syncCheckboxes();
    updateSelectionInfo();
});

document.getElementById('selectOddPages').addEventListener('click', () => {
    pageEditorState.selectedPages.clear();
    pageEditorState.reorderedPages.forEach((page, index) => {
        if (page.number % 2 === 1) {
            pageEditorState.selectedPages.add(index);
        }
    });
    syncCheckboxes();
    updateSelectionInfo();
});

document.getElementById('selectRange').addEventListener('click', () => {
    const rangeInput = document.getElementById('splitRangeInput').value.trim();
    if (!rangeInput) {
        showToast('Enter page range (e.g., 1-5, 10, 15-20)', 'error');
        return;
    }

    try {
        const pageNumbers = parsePageRange(rangeInput);
        if (pageNumbers.length === 0) {
            showToast('Invalid page range', 'error');
            return;
        }

        pageEditorState.selectedPages.clear();

        pageEditorState.reorderedPages.forEach((page, index) => {
            if (!page.deleted && pageNumbers.includes(page.number)) {
                pageEditorState.selectedPages.add(index);
            }
        });

        syncCheckboxes();
        updateSelectionInfo();
        
        showToast(`Selected ${pageEditorState.selectedPages.size} page(s)`, 'success');

    } catch (error) {
        showToast('Error parsing range: ' + error.message, 'error');
    }
});

function syncCheckboxes() {
    pageGrid.querySelectorAll('.page-checkbox').forEach(cb => {
        const index = parseInt(cb.dataset.index);
        cb.checked = pageEditorState.selectedPages.has(index);
        if (cb.checked) {
            cb.closest('.page-thumbnail').classList.add('selected');
        } else {
            cb.closest('.page-thumbnail').classList.remove('selected');
        }
    });
}

document.getElementById('rotateLeft').addEventListener('click', async () => {
    if (pageEditorState.selectedPages.size === 0) {
        showToast('No pages selected', 'error');
        return;
    }
    
    saveUndoState('Rotate Left');
    
    const indicesToUpdate = Array.from(pageEditorState.selectedPages);
    
    for (const index of indicesToUpdate) {
        const page = pageEditorState.reorderedPages[index];
        page.rotation = (page.rotation - 90 + 360) % 360;
        await updateSingleThumbnail(index);
    }
    
    showToast(`Rotated ${pageEditorState.selectedPages.size} page(s) left`, 'success');
});

document.getElementById('rotateRight').addEventListener('click', async () => {
    if (pageEditorState.selectedPages.size === 0) {
        showToast('No pages selected', 'error');
        return;
    }
    
    saveUndoState('Rotate Right');
    
    const indicesToUpdate = Array.from(pageEditorState.selectedPages);
    
    for (const index of indicesToUpdate) {
        const page = pageEditorState.reorderedPages[index];
        page.rotation = (page.rotation + 90) % 360;
        await updateSingleThumbnail(index);
    }
    
    showToast(`Rotated ${pageEditorState.selectedPages.size} page(s) right`, 'success');
});

document.getElementById('rotate180').addEventListener('click', async () => {
    if (pageEditorState.selectedPages.size === 0) {
        showToast('No pages selected', 'error');
        return;
    }
    
    saveUndoState('Rotate 180¬∞');
    
    const indicesToUpdate = Array.from(pageEditorState.selectedPages);
    
    for (const index of indicesToUpdate) {
        const page = pageEditorState.reorderedPages[index];
        page.rotation = (page.rotation + 180) % 360;
        await updateSingleThumbnail(index);
    }
    
    showToast(`Rotated ${pageEditorState.selectedPages.size} page(s) 180¬∞`, 'success');
});

async function updateSingleThumbnail(index) {
    const pageData = pageEditorState.reorderedPages[index];
    const thumbnail = pageGrid.querySelector(`[data-index="${index}"]`);
    if (!thumbnail || pageData.deleted) return;

    const page = await pdfJsDoc.getPage(pageData.number);
    const scale = 0.5;
    const viewport = page.getViewport({ scale, rotation: pageData.rotation });

    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d');
    canvas.height = viewport.height;
    canvas.width = viewport.width;

    await page.render({
        canvasContext: context,
        viewport: viewport
    }).promise;

    const thumbnailCanvas = thumbnail.querySelector('.page-thumbnail-canvas');
    thumbnailCanvas.width = canvas.width;
    thumbnailCanvas.height = canvas.height;
    const ctx = thumbnailCanvas.getContext('2d');
    ctx.drawImage(canvas, 0, 0);

    const oldIndicator = thumbnail.querySelector('.rotation-indicator');
    if (oldIndicator) oldIndicator.remove();
    
    if (pageData.rotation !== 0) {
        const indicator = document.createElement('span');
        indicator.className = 'rotation-indicator';
        indicator.textContent = `${pageData.rotation}¬∞`;
        thumbnail.insertBefore(indicator, thumbnail.querySelector('.page-thumbnail-canvas'));
    }

    const actualWidth = Math.round(viewport.width * 2);
    const actualHeight = Math.round(viewport.height * 2);
    const sizeSpan = thumbnail.querySelector('.page-size');
    if (sizeSpan) {
        sizeSpan.textContent = `${actualWidth} √ó ${actualHeight}`;
    }
}

document.getElementById('deleteSelected').addEventListener('click', () => {
    if (pageEditorState.selectedPages.size === 0) {
        showToast('No pages selected', 'error');
        return;
    }
    
    const remainingPages = pageEditorState.reorderedPages.filter(p => !p.deleted).length - pageEditorState.selectedPages.size;
    if (remainingPages === 0) {
        showToast('Cannot delete all pages', 'error');
        return;
    }

    if (!confirm(`Delete ${pageEditorState.selectedPages.size} page(s)?`)) {
        return;
    }

    saveUndoState('Delete Pages');

    const indicesToDelete = Array.from(pageEditorState.selectedPages);
    indicesToDelete.forEach(index => {
        pageEditorState.reorderedPages[index].deleted = true;
        
        const thumbnail = pageGrid.querySelector(`[data-index="${index}"]`);
        if (thumbnail) {
            thumbnail.classList.add('deleted');
            const checkbox = thumbnail.querySelector('.page-checkbox');
            if (checkbox) {
                checkbox.checked = false;
                checkbox.disabled = true;
            }
        }
    });

    pageEditorState.selectedPages.clear();
    updateSelectionInfo();
    
    showToast(`Marked ${indicesToDelete.length} page(s) for deletion`, 'success');
});

document.getElementById('splitExtract').addEventListener('click', async () => {
    const rangeInput = document.getElementById('splitRangeInput').value.trim();
    if (!rangeInput) {
        showToast('Enter page range (e.g., 1-5, 10, 15-20)', 'error');
        return;
    }

    try {
        const pageNumbers = parsePageRange(rangeInput);
        if (pageNumbers.length === 0) {
            showToast('Invalid page range', 'error');
            return;
        }

        showToast('Extracting pages...', 'info');

        const newPdf = await PDFDocument.create();
        
        for (const pageNum of pageNumbers) {
            if (pageNum < 1 || pageNum > totalPages) {
                showToast(`Page ${pageNum} out of range`, 'error');
                return;
            }
            const [copiedPage] = await newPdf.copyPages(pdfDoc, [pageNum - 1]);
            newPdf.addPage(copiedPage);
        }

        const pdfBytes = await newPdf.save();
        const blob = new Blob([pdfBytes], { type: 'application/pdf' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = pdfFileName.replace('.pdf', `_pages_${rangeInput.replace(/[,\s]/g, '_')}.pdf`);
        a.click();
        URL.revokeObjectURL(url);

        showToast(`Extracted ${pageNumbers.length} page(s)`, 'success');
        document.getElementById('splitRangeInput').value = '';

    } catch (error) {
        showToast('Error extracting pages: ' + error.message, 'error');
        console.error(error);
    }
});

function parsePageRange(rangeStr) {
    const pages = new Set();
    const parts = rangeStr.split(',');
    
    for (const part of parts) {
        const trimmed = part.trim();
        if (trimmed.includes('-')) {
            const [start, end] = trimmed.split('-').map(s => parseInt(s.trim()));
            if (isNaN(start) || isNaN(end)) continue;
            for (let i = Math.min(start, end); i <= Math.max(start, end); i++) {
                pages.add(i);
            }
        } else {
            const num = parseInt(trimmed);
            if (!isNaN(num)) {
                pages.add(num);
            }
        }
    }
    
    return Array.from(pages).sort((a, b) => a - b);
}

function updateSelectionInfo() {
    const count = pageEditorState.selectedPages.size;
    selectionCount.textContent = count === 0 ? 'No pages selected' : 
                                 count === 1 ? '1 page selected' : 
                                 `${count} pages selected`;
}

document.getElementById('applyPageChanges').addEventListener('click', async () => {
    try {
        showToast('Applying changes...', 'info');

        const newPdf = await PDFDocument.create();
        
        const finalPages = pageEditorState.reorderedPages.filter(p => !p.deleted);
        
        if (finalPages.length === 0) {
            showToast('Cannot create PDF with no pages', 'error');
            return;
        }

        for (const pageData of finalPages) {
            const [copiedPage] = await newPdf.copyPages(pdfDoc, [pageData.number - 1]);
            
            if (pageData.rotation !== 0) {
                copiedPage.setRotation({ angle: pageData.rotation, type: 'degrees' });
            }
            
            newPdf.addPage(copiedPage);
        }

        if (bookmarks.length > 0) {
            const pageMapping = new Map();
            finalPages.forEach((pageData, newIndex) => {
                pageMapping.set(pageData.number, newIndex + 1);
            });

            const adjustedBookmarks = bookmarks
                .filter(b => pageMapping.has(b.page))
                .map(b => ({
                    ...b,
                    page: pageMapping.get(b.page)
                }));

            if (adjustedBookmarks.length > 0) {
                const context = newPdf.context;
                const outlinesRef = context.nextRef();
                const outlines = context.obj({ Type: 'Outlines' });

                const itemRefs = [];
                const items = [];

                adjustedBookmarks.forEach((bookmark) => {
                    const page = newPdf.getPage(bookmark.page - 1);
                    const itemRef = context.nextRef();
                    itemRefs.push(itemRef);

                    items.push({
                        Title: PDFString.of(cleanBookmarkTitle(bookmark.title)),
                        Parent: outlinesRef,
                        Dest: [page.ref, 'XYZ', null, null, null]
                    });
                });

                items.forEach((item, index) => {
                    if (index > 0) item.Prev = itemRefs[index - 1];
                    if (index < items.length - 1) item.Next = itemRefs[index + 1];
                });

                items.forEach((item, index) => {
                    context.assign(itemRefs[index], context.obj(item));
                });

                if (itemRefs.length > 0) {
                    outlines.set(PDFName.of('First'), itemRefs[0]);
                    outlines.set(PDFName.of('Last'), itemRefs[itemRefs.length - 1]);
                    outlines.set(PDFName.of('Count'), PDFNumber.of(itemRefs.length));
                }

                context.assign(outlinesRef, outlines);
                newPdf.catalog.set(PDFName.of('Outlines'), outlinesRef);
            }
        }

        const pdfBytes = await newPdf.save();
        const blob = new Blob([pdfBytes], { type: 'application/pdf' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = pdfFileName.replace('.pdf', '_edited.pdf');
        a.click();
        URL.revokeObjectURL(url);

        showToast(`PDF saved with ${finalPages.length} page(s)`, 'success');
        pageEditorModal.classList.add('hidden');

    } catch (error) {
        showToast('Error applying changes: ' + error.message, 'error');
        console.error(error);
    }
});

if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
        navigator.serviceWorker.register('./service-worker.js')
            .then((registration) => {
                console.log('ServiceWorker registered:', registration.scope);
            })
            .catch((error) => {
                console.log('ServiceWorker registration failed:', error);
            });
    });
}
    </script>
</body>
</html>
</body>
</html>