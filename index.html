<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Bookmark Editor</title>
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#667eea">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="PDF Editor">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            color: #fff;
            height: 100vh;
            overflow: hidden;
        }
        
        .app-layout {
            display: flex;
            height: 100vh;
        }
        
        .pdf-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #16213e;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .pdf-header {
            padding: 8px 15px;
            background: rgba(0, 0, 0, 0.2);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .file-input-wrapper {
            display: inline-block;
        }

        .file-input-wrapper label {
            margin: 0;
            display: inline-block;
            line-height: normal;
        }
        
        input[type="file"] {
            display: none;
        }
        
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #e8e8e8;
        }
        
        .btn-primary:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }
        
        .pdf-info {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 15px;
            color: #aaa;
            font-size: 13px;
            margin-left: 10px;
        }

        #pdfName {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .page-nav {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        #zoomControls {
            display: none;
            gap: 6px;
        }
        
        .page-nav button {
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
        }
        
        .page-nav button:hover:not(:disabled) {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .page-nav button:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
        
        .page-nav input {
            width: 60px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 6px;
            border-radius: 4px;
            text-align: center;
        }

       .pdf-page.dark-mode {
           filter: invert(1) hue-rotate(180deg);
       }
       
       .pdf-page.grayscale-mode {
           filter: grayscale(85%) invert(85%);
       }
        
        .pdf-viewer-container {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            background: #0f1419;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            position: relative;
        }
        
        #pdfViewer {
            max-width: 100%;
            display: none;
        }
        
        #pdfViewer.active {
            display: block;
        }
        
        .pdf-page {
            margin-bottom: 20px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }
        
        .bookmarks-panel {
            width: 350px;
            display: flex;
            flex-direction: column;
            background: #1a1a2e;
        }
        
        .bookmarks-header {
            padding: 12px 20px;
            background: rgba(0, 0, 0, 0.2);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .bookmarks-header h2 {
            margin-bottom: 8px;
            font-size: 1.2em;
        }
        
        .keyboard-shortcuts {
            background: rgba(102, 126, 234, 0.1);
            padding: 8px 10px;
            border-radius: 6px;
            font-size: 11px;
            line-height: 1.5;
            color: #aaa;
        }
        
        .keyboard-shortcuts kbd {
            background: rgba(0, 0, 0, 0.3);
            padding: 2px 6px;
            border-radius: 3px;
            font-family: monospace;
            color: #fff;
            font-size: 11px;
        }

        .keyboard-shortcuts .level-1-text {
            color: #667eea;
        }
        
        .keyboard-shortcuts .level-2-text {
            color: #38ef7d;
        }
        
        .keyboard-shortcuts .level-3-text {
            color: #f39c12;
        }
        
        .bookmarks-list {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
        }
        
        .bookmarks-list::-webkit-scrollbar {
            width: 8px;
        }
        
        .bookmarks-list::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
        }
        
        .bookmarks-list::-webkit-scrollbar-thumb {
            background: rgba(102, 126, 234, 0.5);
            border-radius: 4px;
        }
        
        .bookmark-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 10px 12px;
            margin-bottom: 8px;
            border-radius: 6px;
            border-left: 3px solid #667eea;
            transition: all 0.2s;
        }
        
        .bookmark-item:hover {
            background: rgba(255, 255, 255, 0.08);
        }
        
        .bookmark-item.level-2 {
            border-left-color: #38ef7d;
            margin-left: 20px;
        }
        
        .bookmark-item.level-3 {
            border-left-color: #f39c12;
            margin-left: 40px;
        }
        
        .bookmark-item-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }
        
        .bookmark-page {
            background: rgba(102, 126, 234, 0.2);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
        }
        
        .bookmark-page.clickable {
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .bookmark-page.clickable:hover {
            background: rgba(102, 126, 234, 0.4);
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
        }
        
        .bookmark-page.clickable:active {
            transform: translateY(0);
        }
        
        .bookmark-item input {
            width: 100%;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #fff;
            padding: 8px;
            border-radius: 4px;
            font-size: 14px;
        }
        
        .bookmark-item input:focus {
            outline: none;
            border-color: rgba(102, 126, 234, 0.5);
        }
        
        .bookmark-actions {
            display: flex;
            gap: 6px;
        }
        
        .pdf-page {
            display: block;
        }

        .page-editor-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(5px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            animation: fadeIn 0.2s ease;
            padding: 10px 0;
            overflow: hidden;
        }
        
        .page-editor-modal.hidden {
            display: none;
        }
        
        .page-editor-content {
            background: #1a1a2e;
            border-radius: 12px;
            width: 95%;
            height: calc(100vh - 20px);
            max-width: 1400px;
            display: flex;
            flex-direction: column;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            animation: slideUp 0.3s ease;
            overflow: hidden;
        }
        
        .page-editor-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 25px;
            background: rgba(0, 0, 0, 0.2);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .page-editor-toolbar {
            display: flex;
            gap: 10px;
            align-items: center;
            padding: 10px 15px;
            background: rgba(0, 0, 0, 0.3);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            flex-wrap: wrap;
        }

        #closeSearch {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: #fff;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        #closeSearch:hover {
            background: rgba(255, 255, 255, 0.2);
            color: #fff;
        }
        
        .toolbar-group {
            display: flex;
            gap: 8px;
            align-items: center;
            padding-right: 15px;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .toolbar-group:last-child {
            border-right: none;
        }
        
        .toolbar-label {
            font-size: 12px;
            color: #888;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .page-grid-container {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
            background: #0f1419;
        }
        
        .page-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 20px;
        }
        
        .page-thumbnail {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            padding: 12px;
            cursor: pointer;
            border: 3px solid transparent;
            transition: all 0.2s;
            position: relative;
        }
        
        .page-thumbnail:hover {
            background: rgba(255, 255, 255, 0.08);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        
        .page-thumbnail.selected {
            border-color: #667eea;
            background: rgba(102, 126, 234, 0.1);
        }
        
        .page-thumbnail.dragging {
            opacity: 0.5;
        }
        
        .page-thumbnail.drag-over {
            border-color: #38ef7d;
            background: rgba(56, 239, 125, 0.1);
        }
        
        .page-thumbnail-canvas {
            width: 100%;
            height: auto;
            border-radius: 4px;
            background: white;
            display: block;
        }
        
        .page-thumbnail-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 10px;
            font-size: 13px;
        }
        
        .page-number {
            color: #667eea;
            font-weight: 600;
        }
        
        .page-size {
            color: #888;
            font-size: 11px;
        }
        
        .page-checkbox {
            position: absolute;
            top: 18px;
            left: 18px;
            width: 24px;
            height: 24px;
            cursor: pointer;
            z-index: 10;
        }

        .page-thumbnail.deleted {
            pointer-events: none;
            opacity: 0.4;
            position: relative;
        }
        
        .page-thumbnail.deleted::before {
            content: 'üóëÔ∏è';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 72px;
            z-index: 100;
            text-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
            pointer-events: none;
        }
        
        .page-thumbnail.deleted::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 8px;
            z-index: 99;
            pointer-events: none;
        }
        
        .rotation-indicator {
            position: absolute;
            top: 18px;
            right: 18px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
        }

        .page-editor-actions {
            display: flex;
            gap: 12px;
            padding: 12px 25px;
            background: rgba(0, 0, 0, 0.2);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            align-items: center;
        }

       .page-editor-actions .btn {
           padding: 10px 16px;
           font-size: 14px;
           white-space: nowrap;
       }
        
        .selection-info {
            flex: 1;
            display: flex;
            align-items: center;
            color: #888;
            font-size: 13px;
            white-space: nowrap;
        }
        
        .selection-info strong {
            color: #667eea;
            margin: 0 4px;
        }
        
        .btn-icon {
            padding: 8px 16px;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .btn-icon-only {
            padding: 8px 12px;
            font-size: 18px;
            line-height: 1;
            min-width: auto;
            background: transparent !important;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .btn-icon-only:hover:not(:disabled) {
            background: rgba(255, 255, 255, 0.1) !important;
            border-color: rgba(255, 255, 255, 0.3);
        }
        
        .btn-icon-only:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .btn-icon-header {
            background: transparent;
            border: 1px solid rgba(102, 126, 234, 0.4);
            color: #667eea;
            padding: 6px 10px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 18px;
            transition: all 0.2s;
            line-height: 1;
        }
        
        .btn-icon-header:hover:not(:disabled) {
            background: rgba(102, 126, 234, 0.2);
            border-color: rgba(102, 126, 234, 0.6);
            transform: translateY(-1px);
        }
        
        .btn-icon-header:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
        
        .bookmarks-header h2 {
            margin: 0;
            font-size: 1.2em;
        }
        
        .split-range-input {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 13px;
            width: 200px;
        }
        
        .split-range-input:focus {
            outline: none;
            border-color: rgba(102, 126, 234, 0.5);
        }
        
        .split-range-input::placeholder {
            color: #666;
        }
        
        .textLayer {
            position: absolute;
            left: 0;
            top: 0;
            right: 0;
            bottom: 0;
            overflow: hidden;
            opacity: 0.4;
            line-height: 1;
            --scale-factor: 1.5;
        }
        
        .textLayer > span {
            color: transparent;
            position: absolute;
            white-space: pre;
            cursor: text;
            transform-origin: 0% 0%;
        }
        
        .textLayer ::selection {
            background: rgba(255, 235, 59, 0.6);
            color: inherit;
        }
        
        .textLayer ::-moz-selection {
            background: rgba(255, 235, 59, 0.6);
            color: inherit;
        }
        
        .btn-small {
            padding: 4px 8px;
            font-size: 12px;
        }
        
        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }
        
        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.15);
        }
        
        .btn-delete {
            background: transparent;
            color: #e74c3c;
            border: 1px solid rgba(231, 76, 60, 0.3);
        }
        
        .btn-delete:hover {
            background: rgba(231, 76, 60, 0.2);
            border-color: rgba(231, 76, 60, 0.5);
        }
        
        
        .bookmarks-footer {
            padding: 15px;
            background: rgba(0, 0, 0, 0.2);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .footer-buttons {
            display: flex;
            gap: 8px;
        }
        
        .footer-buttons .btn {
            flex: 1;
            font-size: 11px;
            padding: 8px 10px;
        }

        .footer-buttons label.btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }
        
        .btn-success {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #e8e8e8;
            width: 100%;
            padding: 14px;
            font-size: 16px;
        }
        
        .btn-success:hover:not(:disabled) {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }
        
        .btn-success:disabled {
            background: #555;
            cursor: not-allowed;
            opacity: 0.5;
        }
        
        .empty-state {
            text-align: center;
            padding: 40px 20px;
            color: #666;
        }
        
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(5px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            animation: fadeIn 0.2s ease;
        }
        
        .modal.hidden {
            display: none;
        }
        
        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        @keyframes highlight-pulse {
            0%, 100% {
                opacity: 0.4;
            }
            50% {
                opacity: 0.7;
            }
        }
        
        .search-highlight-overlay {
            animation: highlight-pulse 1.5s ease-in-out infinite;
        }
        
        .modal-content {
            background: #1a1a2e;
            padding: 0;
            border-radius: 12px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            animation: slideUp 0.3s ease;
        }
        
        @keyframes slideUp {
            from {
                transform: translateY(30px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 25px;
            background: rgba(0, 0, 0, 0.2);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .modal-header h3 {
            margin: 0;
            font-size: 1.3em;
        }
        
        .btn-close {
            background: transparent;
            border: none;
            color: #aaa;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            transition: all 0.2s;
        }
        
        .btn-close:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
        }
        
        .modal-content > p {
            color: #aaa;
            margin: 0;
            padding: 15px 25px;
            font-size: 14px;
            background: rgba(102, 126, 234, 0.05);
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }
        
        .merge-file-list {
            padding: 20px 25px;
            max-height: 400px;
            overflow-y: auto;
        }
        
        .merge-file-list::-webkit-scrollbar {
            width: 8px;
        }
        
        .merge-file-list::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
        }
        
        .merge-file-list::-webkit-scrollbar-thumb {
            background: rgba(102, 126, 234, 0.5);
            border-radius: 4px;
        }
        
        .merge-file-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            gap: 12px;
            cursor: grab;
            border: 2px solid transparent;
            transition: all 0.2s;
        }
        
        .merge-file-item:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(102, 126, 234, 0.3);
        }
        
        .merge-file-item.dragging {
            opacity: 0.5;
            cursor: grabbing;
        }
        
        .merge-file-item.drag-over {
            border-color: rgba(102, 126, 234, 0.8);
            background: rgba(102, 126, 234, 0.1);
        }
        
        .drag-handle {
            color: #666;
            font-size: 20px;
            cursor: grab;
            user-select: none;
        }
        
        .merge-file-item.dragging .drag-handle {
            cursor: grabbing;
        }
        
        .file-order {
            background: rgba(102, 126, 234, 0.3);
            color: white;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 13px;
            flex-shrink: 0;
        }
        
        .file-info {
            flex: 1;
            min-width: 0;
        }
        
        .file-name {
            font-weight: 600;
            color: #fff;
            margin-bottom: 4px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .file-pages {
            font-size: 12px;
            color: #888;
        }
        
        .remove-file {
            background: transparent;
            border: 1px solid rgba(231, 76, 60, 0.3);
            color: #e74c3c;
            padding: 6px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
            flex-shrink: 0;
        }
        
        .remove-file:hover {
            background: rgba(231, 76, 60, 0.2);
            border-color: rgba(231, 76, 60, 0.5);
        }
        
        .modal-actions {
            display: flex;
            gap: 12px;
            padding: 20px 25px;
            background: rgba(0, 0, 0, 0.2);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .modal-actions .btn {
            flex: 1;
            padding: 12px;
        }
        
        .empty-merge-list {
            text-align: center;
            padding: 40px 20px;
            color: #666;
        }

        .pdf-search-section {
            padding: 15px;
            background: rgba(0, 0, 0, 0.2);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            margin-bottom: 10px;
            flex-shrink: 0;
        }
        
        .search-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .search-header h3 {
            margin: 0;
            font-size: 1.1em;
            color: #fff;
        }
        
        .search-result-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 10px;
            margin-bottom: 8px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            border-left: 3px solid #667eea;
        }
        
        .search-result-item:hover {
            background: rgba(255, 255, 255, 0.08);
            transform: translateX(3px);
        }
        
        .search-result-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 6px;
            font-size: 12px;
        }
        
        .search-result-page {
            color: #667eea;
            font-weight: 600;
        }
        
        .search-result-score {
            color: #888;
        }
        
        .search-result-text {
            font-size: 13px;
            line-height: 1.5;
            color: #ddd;
        }
        
        .search-result-text mark {
            background: #ffeb3b;
            color: #000;
            padding: 0;
            border-radius: 2px;
            font-weight: 600;
        }
        
        #pdfSearchBox:focus {
            outline: none;
            border-color: rgba(102, 126, 234, 0.8);
        }
        
        .toast {
            position: fixed;
            bottom: 30px;
            right: 30px;
            background: rgba(102, 126, 234, 0.95);
            backdrop-filter: blur(10px);
            color: white;
            padding: 15px 20px;
            border-radius: 8px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            transform: translateX(400px);
            transition: transform 0.3s ease;
            z-index: 10000; /* Increased z-index */
            max-width: 350px;
            word-wrap: break-word;
        }
        
        .toast.show {
            transform: translateX(0);
        }
        
        .toast.error {
            background: rgba(231, 76, 60, 0.95);
        }
        
        .toast.success {
            background: rgba(17, 153, 142, 0.95);
        }
        
        .toast.info {
            background: rgba(102, 126, 234, 0.95);
        }
        
        @keyframes bookmark-highlight {
            0% {
                background: rgba(102, 126, 234, 0.4);
                transform: scale(1.02);
            }
            100% {
                background: rgba(255, 255, 255, 0.05);
                transform: scale(1);
            }
        }
        
        .bookmark-item.newly-added {
            animation: bookmark-highlight 0.6s ease-out;
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #aaa;
            font-size: 18px;
            pointer-events: none;
        }
        
        .loading.hidden {
            display: none;
        }
        
        @media (max-width: 1024px) {
            .app-layout {
                flex-direction: column;
            }
        
            .bookmarks-panel {
                width: 400px;
                display: flex;
                flex-direction: column;
                background: #1a1a2e;
                height: 100vh;
                overflow: hidden;
            }
            
            .bookmarks-list {
                flex: 1;
                overflow-y: auto;
                padding: 15px;
                min-height: 0;
            }

            .github-link {
                color: #aaa;
                transition: all 0.2s;
                display: flex;
                align-items: center;
                padding: 4px;
                border-radius: 4px;
            }
            
            .github-link:hover {
                color: #667eea;
                background: rgba(102, 126, 234, 0.1);
            }
            
            .github-link svg {
                display: block;
            }
        }
    </style>
</head>
<body>
    <div class="app-layout">
        <div class="pdf-panel">
            <div class="pdf-header">
                <div class="file-input-wrapper">
                    <input type="file" id="pdfInput" accept=".pdf">
                    <label for="pdfInput" class="btn btn-primary btn-icon-only" title="Open PDF">
                        üìÑ
                    </label>
                </div>
                <div class="file-input-wrapper">
                    <input type="file" id="mergePdfInput" accept=".pdf" multiple>
                    <label for="mergePdfInput" class="btn btn-primary btn-icon-only" title="Merge PDFs">
                        üîó
                    </label>
                </div>
                <button id="openPageEditor" class="btn btn-primary btn-icon-only" disabled title="Edit Pages">
                    ‚úÇÔ∏è
                </button>
                <div class="pdf-info">
                    <span id="pdfName"></span>
                    <div style="flex: 1;"></div>
                    <div id="currentPageDisplay" style="color: #667eea; font-weight: 600; line-height: 1.3; text-align: right; min-width: 80px;"></div>
                    <div id="zoomControls" style="display: none; gap: 8px;">
                        <button id="zoomOut" class="btn btn-secondary btn-icon-only" title="Zoom out">‚àí</button>
                        <button id="zoomIn" class="btn btn-secondary btn-icon-only" title="Zoom in">+</button>
                        <button id="togglePdfDarkMode" class="btn btn-secondary btn-icon-only" title="Toggle PDF color mode">üåô</button>
                    </div>
                </div>
            </div>
            <div class="pdf-viewer-container" id="pdfViewerContainer">
                <div class="loading" id="loading">Select a PDF to get started</div>
                <canvas id="pdfViewer"></canvas>
            </div>
        </div>

        <div class="bookmarks-panel">
            <div class="bookmarks-header">
                <div style="display: flex; align-items: center; justify-content: space-between; width: 100%;">
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <h2>Add / Edit Bookmarks</h2>
                        <button id="applyBookmarksBtn" class="btn-icon-header" disabled title="Create PDF with Bookmarks">
                            üíæ
                        </button>
                    </div>
                    <a href="https://github.com/mrfragger/pdf-bookmark-editor" target="_blank" rel="noopener noreferrer" class="github-link" title="View on GitHub">
                        <svg width="20" height="20" viewBox="0 0 16 16" fill="currentColor">
                            <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"/>
                        </svg>
                    </a>
                </div>
                <div class="keyboard-shortcuts">
                    <kbd>Cmd/Ctrl</kbd> + <kbd>A</kbd> <span class="level-1-text">Chapter (Level 1)</span><br>
                    <kbd>Cmd/Ctrl</kbd> + <kbd>S</kbd> <span class="level-2-text">Section (Level 2)</span><br>
                    <kbd>Cmd/Ctrl</kbd> + <kbd>D</kbd> <span class="level-3-text">Subsection (Level 3)</span>
                </div>
            </div>

            <div class="pdf-search-section" id="pdfSearchSection" style="display: none;">
                <div class="search-header">
                    <h3>üîç Search <span id="searchPageIndicator" style="color: #888; font-size: 0.9em; font-weight: normal;"></span></h3>
                    <div style="display: flex; gap: 8px; align-items: center;">
                        <button id="searchHelp" class="btn-small" style="background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3); padding: 4px 10px; color: #fff; font-size: 14px; cursor: pointer; border-radius: 4px; font-weight: bold;" title="&quot;feet hands&quot; finds exact phrase&#10;&quot;here&quot; or 'here' finds only &quot;here&quot; (not &quot;there&quot; or &quot;hereafter&quot;)&#10;Fuzzy match ‚Äî fet finds &quot;feet&quot;, &quot;fetter&quot;&#10;Prefix search ‚Äî here finds &quot;here&quot;, &quot;there&quot;, &quot;hereafter&quot;">?</button>
                        <button id="clearSearch" class="btn-small" style="background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3); padding: 4px 12px; color: #fff; font-size: 13px; cursor: pointer; border-radius: 4px;" title="Clear results ( Cmd/Ctrl+/ )">Clear</button>
                        <button id="closeSearch" title="Close search (Esc)">‚úï</button>
                    </div>
                </div>
                <input type="text" id="pdfSearchBox" placeholder="Search for multiple terms..." 
                       style="width: 100%; padding: 10px; background: rgba(0,0,0,0.3); border: 1px solid rgba(102,126,234,0.5); color: white; border-radius: 4px; margin-bottom: 10px; font-size: 14px;">
                <div class="search-options" style="margin-bottom: 10px; font-size: 11px; line-height: 1.6;">
                    <label style="display: block; margin: 4px 0; cursor: pointer;">
                        <input type="checkbox" id="searchFuzzy" checked> Fuzzy match
                    </label>
                    <label style="display: block; margin: 4px 0; cursor: pointer;">
                        <input type="checkbox" id="searchPrefix" checked> Prefix search
                    </label>
                </div>
                <div id="searchStatus" style="color: #888; font-size: 12px; margin-bottom: 10px;"></div>
                <div id="searchResults" style="max-height: 400px; overflow-y: auto;"></div>
            </div>
            
            <div class="bookmarks-list" id="bookmarksList">
                <div class="empty-state">
                    <p>No bookmarks yet</p>
                    <p style="margin-top: 10px; font-size: 13px;">
                        Select text in PDF and use keyboard shortcuts
                    </p>
                </div>
            </div>

            <div class="bookmarks-footer">
                <div class="footer-buttons">
                    <button id="openSearchBtn" class="btn btn-secondary btn-small" disabled title="Search PDF ( / )">
                        Search
                    </button>
                    <input type="file" id="importInput" accept=".txt" style="display: none;">
                    <label for="importInput" class="btn btn-secondary btn-small" style="cursor: pointer; margin: 0;">
                        Import
                    </label>
                    <button id="exportBtn" class="btn btn-secondary btn-small">Export</button>
                    <button id="loadExistingBtn" class="btn btn-secondary btn-small" disabled>
                        Load Existing
                    </button>
                </div>
            </div>

            <div id="pageEditorModal" class="page-editor-modal hidden">
                <div class="page-editor-content">
                    <div class="page-editor-toolbar">
                        <div class="toolbar-group">
                            <span class="toolbar-label">Select</span>
                            <button id="selectAllPages" class="btn btn-secondary btn-small">All</button>
                            <button id="selectNonePages" class="btn btn-secondary btn-small">None</button>
                            <button id="selectEvenPages" class="btn btn-secondary btn-small">Even</button>
                            <button id="selectOddPages" class="btn btn-secondary btn-small">Odd</button>
                            <button id="selectInvertPages" class="btn btn-secondary btn-small">Invert</button>
                        </div>
                        
                        <div class="toolbar-group">
                            <span class="toolbar-label">Rotate</span>
                            <button id="rotateLeft" class="btn btn-secondary btn-small btn-icon" title="Rotate 90¬∞ Left">‚Ü∫ 90¬∞</button>
                            <button id="rotateRight" class="btn btn-secondary btn-small btn-icon" title="Rotate 90¬∞ Right">‚Üª 90¬∞</button>
                            <button id="rotate180" class="btn btn-secondary btn-small btn-icon" title="Rotate 180¬∞">‚Üª 180¬∞</button>
                        </div>
                        
                        <div class="toolbar-group">
                            <span class="toolbar-label">Actions</span>
                            <button id="deleteSelected" class="btn btn-delete btn-small btn-icon">üóëÔ∏è Delete</button>
                        </div>
                        
                        <div class="toolbar-group">
                            <span class="toolbar-label">Range</span>
                            <input type="text" id="splitRangeInput" class="split-range-input" placeholder="e.g., 1-5, 10, 15-20">
                            <button id="selectRange" class="btn btn-secondary btn-small">Select</button>
                            <button id="splitExtract" class="btn btn-primary btn-small">Extract</button>
                        </div>
            
                        <div style="flex: 1;"></div>
                        
                        <button id="closePageEditor" class="btn btn-secondary btn-small">‚úï Close</button>
                    </div>
            
                    <div class="page-grid-container" id="pageGridContainer">
                        <div id="pageGrid" class="page-grid"></div>
                    </div>
            
                    <div class="page-editor-actions">
                        <div class="selection-info">
                            <span id="selectionCount">0 pages selected</span>
                        </div>
                        <button id="cancelPageEdit" class="btn btn-secondary">Cancel</button>
                        <button id="undoButton" class="btn btn-secondary" disabled>
                            ‚Ü∂ Undo <kbd>Cmd/Ctrl+Z</kbd>
                        </button>
                        <button id="applyPageChanges" class="btn btn-success">Apply Changes</button>
                    </div>
                </div>
            </div>
            </div>
        </div>
    </div>

    <div id="toast" class="toast"></div>

    <div id="mergeModal" class="modal hidden">
        <div class="modal-content">
            <div class="modal-header">
                <h3>üîó Merge PDFs</h3>
                <button id="closeMergeModal" class="btn-close">‚úï</button>
            </div>
            <p>Drag files to reorder them before merging</p>
            <div id="mergeFileList" class="merge-file-list"></div>
            <div class="modal-actions">
                <button id="cancelMerge" class="btn btn-secondary">Cancel</button>
                <button id="confirmMerge" class="btn btn-success">Merge PDFs</button>
            </div>
        </div>
    </div>

    <script src="pdf.min.js"></script>
    <script src="pdf-lib.min.js"></script>
    <script src="index.min.js"></script>
    <script>
pdfjsLib.GlobalWorkerOptions.workerSrc = 'pdf.worker.min.js';

const { PDFDocument, PDFName, PDFString, PDFNumber } = PDFLib;

let pdfDoc = null;
let pdfBytes = null;
let pdfFileName = '';
let bookmarks = [];
let currentPage = 1;
let totalPages = 0;
let pdfJsDoc = null;
let renderTask = null;
let originalFile = null;
let toastTimeout = null;
let lastTitleCaseOperation = null;
let mergeFiles = [];
let draggedElement = null;
let visiblePages = new Set();
let pageCache = new Map();
let undoStack = [];

const pdfInput = document.getElementById('pdfInput');
const pdfName = document.getElementById('pdfName');
const pdfViewer = document.getElementById('pdfViewer');
const pdfViewerContainer = document.getElementById('pdfViewerContainer');
const loadingEl = document.getElementById('loading');
const bookmarksList = document.getElementById('bookmarksList');
const importInput = document.getElementById('importInput');
const exportBtn = document.getElementById('exportBtn');
const applyBookmarksBtn = document.getElementById('applyBookmarksBtn');
const mergePdfInput = document.getElementById('mergePdfInput');
const mergeModal = document.getElementById('mergeModal');
const mergeFileList = document.getElementById('mergeFileList');
const confirmMergeBtn = document.getElementById('confirmMerge');
const cancelMergeBtn = document.getElementById('cancelMerge');
const closeMergeModalBtn = document.getElementById('closeMergeModal');
const PAGES_TO_RENDER_AHEAD = 2;
const INITIAL_PAGES_TO_LOAD = 3;
const MAX_UNDO_STACK = 50;

function saveUndoState(action) {
    const state = {
        action: action,
        pages: JSON.parse(JSON.stringify(pageEditorState.reorderedPages)),
        selectedPages: new Set(pageEditorState.selectedPages),
        timestamp: Date.now()
    };
    
    undoStack.push(state);
    
    if (undoStack.length > MAX_UNDO_STACK) {
        undoStack.shift();
    }
    
    updateUndoButton();
}

function undo() {
    if (undoStack.length === 0) {
        showToast('Nothing to undo', 'info');
        return;
    }
    
    const previousState = undoStack.pop();
    
    pageEditorState.reorderedPages = JSON.parse(JSON.stringify(previousState.pages));
    pageEditorState.selectedPages = new Set(previousState.selectedPages);
    
    const container = document.getElementById('pageGridContainer');
    const scrollPos = container.scrollTop;
    
    renderPageGrid().then(() => {
        container.scrollTop = scrollPos;
        syncCheckboxes();
        updateSelectionInfo();
    });
    
    showToast(`Undid: ${previousState.action}`, 'success');
    
    updateUndoButton();
}

function updateUndoButton() {
    const btn = document.getElementById('undoButton');
    btn.disabled = undoStack.length === 0;
}

document.getElementById('undoButton').addEventListener('click', undo);

document.addEventListener('keydown', (e) => {
    const modifier = (navigator.platform.toUpperCase().indexOf('MAC') >= 0) ? e.metaKey : e.ctrlKey;
    
    if (modifier && e.key === 'z' && !pageEditorModal.classList.contains('hidden')) {
        e.preventDefault();
        undo();
    }
});

mergePdfInput.addEventListener('change', async (e) => {
    const files = Array.from(e.target.files);
    if (files.length < 2) {
        showToast('Please select at least 2 PDFs to merge', 'error');
        mergePdfInput.value = '';
        return;
    }

    try {
        showToast('Loading PDFs...', 'info');
        
        mergeFiles = [];
        for (const file of files) {
            const arrayBuffer = await file.arrayBuffer();
            const bytes = new Uint8Array(arrayBuffer);
            const pdf = await PDFDocument.load(bytes, { ignoreEncryption: true });
            
            mergeFiles.push({
                file: file,
                name: file.name,
                pageCount: pdf.getPageCount(),
                bytes: bytes
            });
        }

        renderMergeFileList();
        mergeModal.classList.remove('hidden');

    } catch (error) {
        showToast('Error loading PDFs: ' + error.message, 'error');
        console.error(error);
    }

    mergePdfInput.value = '';
});

function renderMergeFileList() {
    if (mergeFiles.length === 0) {
        mergeFileList.innerHTML = `
            <div class="empty-merge-list">
                <p>No files to merge</p>
            </div>
        `;
        return;
    }

    mergeFileList.innerHTML = '';
    
    mergeFiles.forEach((fileData, index) => {
        const div = document.createElement('div');
        div.className = 'merge-file-item';
        div.draggable = true;
        div.dataset.index = index;
        
        div.innerHTML = `
            <span class="drag-handle">‚ãÆ‚ãÆ</span>
            <div class="file-order">${index + 1}</div>
            <div class="file-info">
                <div class="file-name" title="${fileData.name}">${fileData.name}</div>
                <div class="file-pages">${fileData.pageCount} pages</div>
            </div>
            <button class="remove-file" data-index="${index}">Remove</button>
        `;
        
        mergeFileList.appendChild(div);
    });

    const items = mergeFileList.querySelectorAll('.merge-file-item');
    items.forEach(item => {
        item.addEventListener('dragstart', handleDragStart);
        item.addEventListener('dragover', handleDragOver);
        item.addEventListener('drop', handleDrop);
        item.addEventListener('dragend', handleDragEnd);
        item.addEventListener('dragenter', handleDragEnter);
        item.addEventListener('dragleave', handleDragLeave);
    });

    mergeFileList.querySelectorAll('.remove-file').forEach(btn => {
        btn.addEventListener('click', (e) => {
            e.stopPropagation();
            const index = parseInt(e.target.dataset.index);
            mergeFiles.splice(index, 1);
            renderMergeFileList();
            
            if (mergeFiles.length < 2) {
                showToast('Need at least 2 PDFs to merge', 'error');
                if (mergeFiles.length === 0) {
                    closeModal();
                }
            }
        });
    });
}

function handleDragStart(e) {
    draggedElement = this;
    this.classList.add('dragging');
    e.dataTransfer.effectAllowed = 'move';
    e.dataTransfer.setData('text/html', this.innerHTML);
}

function handleDragOver(e) {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';
    return false;
}

function handleDragEnter(e) {
    if (this !== draggedElement) {
        this.classList.add('drag-over');
    }
}

function handleDragLeave(e) {
    this.classList.remove('drag-over');
}

function handleDrop(e) {
    e.stopPropagation();
    e.preventDefault();

    if (draggedElement !== this) {
        const fromIndex = parseInt(draggedElement.dataset.index);
        const toIndex = parseInt(this.dataset.index);

        const movedItem = mergeFiles.splice(fromIndex, 1)[0];
        mergeFiles.splice(toIndex, 0, movedItem);

        renderMergeFileList();
    }

    return false;
}

function handleDragEnd(e) {
    const items = mergeFileList.querySelectorAll('.merge-file-item');
    items.forEach(item => {
        item.classList.remove('dragging');
        item.classList.remove('drag-over');
    });
}

confirmMergeBtn.addEventListener('click', async () => {
    if (mergeFiles.length < 2) {
        showToast('Need at least 2 PDFs to merge', 'error');
        return;
    }

    try {
        closeModal();
        showToast('Merging PDFs...', 'info');

        const mergedPdf = await PDFDocument.create();
        const allBookmarks = [];
        let currentPageOffset = 0;

        for (let i = 0; i < mergeFiles.length; i++) {
            const fileData = mergeFiles[i];
            
            showToast(`Processing ${i + 1}/${mergeFiles.length}: ${fileData.name}`, 'info');
            
            const sourcePdf = await PDFDocument.load(fileData.bytes, { ignoreEncryption: true });
            
            
            const existingBookmarks = await extractExistingBookmarks(sourcePdf);
            
            existingBookmarks.forEach(bookmark => {
                allBookmarks.push({
                    ...bookmark,
                    page: bookmark.page + currentPageOffset,
                    id: Date.now() + Math.random()
                });
            });
            
            const pageIndices = sourcePdf.getPageIndices();
            const copiedPages = await mergedPdf.copyPages(sourcePdf, pageIndices);
            
            copiedPages.forEach((page) => {
                mergedPdf.addPage(page);
            });
            
            currentPageOffset += sourcePdf.getPageCount();
        }

        showToast('Saving merged PDF...', 'info');

        if (allBookmarks.length > 0) {
            showToast('Adding bookmarks to merged PDF...', 'info');
            
            const context = mergedPdf.context;
            const outlinesRef = context.nextRef();
            const outlines = context.obj({
                Type: 'Outlines',
            });

            const itemRefs = [];
            const items = [];

            allBookmarks.forEach((bookmark) => {
                const page = mergedPdf.getPage(bookmark.page - 1);
                const itemRef = context.nextRef();
                itemRefs.push(itemRef);

                const item = {
                    Title: PDFString.of(cleanBookmarkTitle(bookmark.title)),
                    Parent: outlinesRef,
                    Dest: [
                        page.ref,
                        'XYZ',
                        null,
                        null,
                        null
                    ]
                };

                items.push(item);
            });

            items.forEach((item, index) => {
                if (index > 0) {
                    item.Prev = itemRefs[index - 1];
                }
                if (index < items.length - 1) {
                    item.Next = itemRefs[index + 1];
                }
            });

            items.forEach((item, index) => {
                context.assign(itemRefs[index], context.obj(item));
            });

            if (itemRefs.length > 0) {
                outlines.set(PDFName.of('First'), itemRefs[0]);
                outlines.set(PDFName.of('Last'), itemRefs[itemRefs.length - 1]);
                outlines.set(PDFName.of('Count'), PDFNumber.of(itemRefs.length));
            }

            context.assign(outlinesRef, outlines);
            mergedPdf.catalog.set(PDFName.of('Outlines'), outlinesRef);
        }

        const mergedPdfBytes = await mergedPdf.save();

        const blob = new Blob([mergedPdfBytes], { type: 'application/pdf' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'merged.pdf';
        a.click();
        URL.revokeObjectURL(url);

        const totalPages = mergedPdf.getPageCount();
        const bookmarkMsg = allBookmarks.length > 0 ? ` with ${allBookmarks.length} bookmarks` : '';
        showToast(`Successfully merged ${mergeFiles.length} PDFs (${totalPages} pages${bookmarkMsg})!`, 'success');

        mergeFiles = [];

    } catch (error) {
        showToast('Error merging PDFs: ' + error.message, 'error');
        console.error('Merge error details:', error);
    }
});

function closeModal() {
    mergeModal.classList.add('hidden');
}

cancelMergeBtn.addEventListener('click', () => {
    mergeFiles = [];
    closeModal();
});

closeMergeModalBtn.addEventListener('click', () => {
    mergeFiles = [];
    closeModal();
});

mergeModal.addEventListener('click', (e) => {
    if (e.target === mergeModal) {
        mergeFiles = [];
        closeModal();
    }
});

async function loadPdfFile(file) {
    try {
        originalFile = file;
        pdfFileName = file.name;
        const arrayBuffer = await file.arrayBuffer();
        pdfBytes = new Uint8Array(arrayBuffer);
        
        pdfDoc = await PDFDocument.load(pdfBytes, { ignoreEncryption: true });
        
        const loadingTask = pdfjsLib.getDocument({ data: pdfBytes });
        pdfJsDoc = await loadingTask.promise;
        totalPages = pdfJsDoc.numPages;
        
        pdfName.textContent = file.name;
        applyBookmarksBtn.disabled = false;
        zoomControls.style.display = 'flex';
        openPageEditorBtn.disabled = false;
        
        const loadExistingBtn = document.getElementById('loadExistingBtn');
        loadExistingBtn.disabled = false;
        
        await renderAllPages();
        
        renderBookmarks();

        await buildSearchIndex();
        
        showToast('PDF loaded successfully', 'success');
    } catch (error) {
        showToast('Error loading PDF: ' + error.message, 'error');
        console.error(error);
    }
}

function showToast(message, type = 'info', duration = 3000) {
    const toast = document.getElementById('toast');
    
    if (toastTimeout) {
        clearTimeout(toastTimeout);
    }
    
    toast.classList.remove('show');
    
    setTimeout(() => {
        toast.textContent = message;
        toast.className = `toast ${type}`;
        toast.classList.add('show');
        
        toastTimeout = setTimeout(() => {
            toast.classList.remove('show');
            toastTimeout = null;
        }, duration);
    }, 50);
}

function toTitleCase(str) {
    const smallWords = ['the', 'and', 'of', 'in', 'on', 'at', 'by', 'to', 'for', 
                        'with', 'from', 'or', 'a', 'an', 'but', 'nor', 'as', 'if'];
    
    const words = str.toLowerCase().split(' ');
    let firstWordIdx = 0;
    
    if (words[0].match(/^\d+[.\)]?$/) && words.length > 1) {
        firstWordIdx = 1;
    }
    
    for (let i = 0; i < words.length; i++) {
        const word = words[i];
        
        const previousWordEndsWithColon = i > 0 && words[i - 1].endsWith(':');
        
        if (i === firstWordIdx || i === words.length - 1 || previousWordEndsWithColon || !smallWords.includes(word)) {
            words[i] = word.charAt(0).toUpperCase() + word.slice(1);
        }
    }
    
    return words.join(' ');
}

async function extractExistingBookmarks(pdfLibDoc) {
    try {
        const catalog = pdfLibDoc.catalog;
        const outlinesRef = catalog.lookup(PDFName.of('Outlines'));
        
        if (!outlinesRef) {
            return [];
        }

        const existingBookmarks = [];
        const pages = pdfLibDoc.getPages();
        
        const pageRefToNum = new Map();
        pages.forEach((page, index) => {
            const refStr = page.ref.toString();
            pageRefToNum.set(refStr, index + 1);
        });
        
        const firstItemRef = outlinesRef.get(PDFName.of('First'));
        
        if (!firstItemRef) {
            return [];
        }
        
        function traverseOutline(itemRef, level = 1) {
            if (!itemRef) return;
            
            const item = pdfLibDoc.context.lookup(itemRef);
            if (!item) return;

            const titleObj = item.get(PDFName.of('Title'));
            
            if (!titleObj) {
                const nextRef = item.get(PDFName.of('Next'));
                if (nextRef) traverseOutline(nextRef, level);
                return;
            }
            
            const title = titleObj.decodeText ? titleObj.decodeText() : titleObj.toString();
            
            let pageNum = 1;
            const destObj = item.get(PDFName.of('Dest'));
            
            if (destObj) {
                try {
                    let destArray = destObj;
                    
                    if (destArray.array && destArray.array.length > 0) {
                        const pageRefObj = destArray.array[0];
                        
                        let pageRefStr;
                        if (pageRefObj && pageRefObj.toString) {
                            pageRefStr = pageRefObj.toString();
                        } else if (typeof pageRefObj === 'object' && pageRefObj.objectNumber !== undefined) {
                            pageRefStr = `${pageRefObj.objectNumber} ${pageRefObj.generationNumber} R`;
                        }
                        
                        if (pageRefStr && pageRefToNum.has(pageRefStr)) {
                            pageNum = pageRefToNum.get(pageRefStr);
                        }
                    }
                } catch (e) {
                    console.warn('Error extracting page number for bookmark:', title, e);
                }
            }

            existingBookmarks.push({
                id: Date.now() + Math.random(),
                title: title,
                page: pageNum,
                level: Math.min(level, 3)
            });

            const firstRef = item.get(PDFName.of('First'));
            if (firstRef) {
                traverseOutline(firstRef, level + 1);
            }

            const nextRef = item.get(PDFName.of('Next'));
            if (nextRef) {
                traverseOutline(nextRef, level);
            }
        }

        traverseOutline(firstItemRef, 1);

        return existingBookmarks;
        
    } catch (error) {
        console.warn('Could not extract bookmarks:', error);
        return [];
    }
}

let currentZoomScale = 1.5;
const MIN_SCALE = 0.5;
const MAX_SCALE = 3.0;
const SCALE_STEP = 0.25;

const zoomInBtn = document.getElementById('zoomIn');
const zoomOutBtn = document.getElementById('zoomOut');
const zoomControls = document.getElementById('zoomControls');

zoomInBtn.addEventListener('click', () => {
    if (currentZoomScale < MAX_SCALE) {
        const container = pdfViewerContainer;
        const scrollRatio = container.scrollTop / container.scrollHeight;
        
        currentZoomScale = Math.min(MAX_SCALE, currentZoomScale + SCALE_STEP);
        reRenderAllPages().then(() => {
            container.scrollTop = scrollRatio * container.scrollHeight;
        });
    }
});

zoomOutBtn.addEventListener('click', () => {
    if (currentZoomScale > MIN_SCALE) {
        const container = pdfViewerContainer;
        const scrollRatio = container.scrollTop / container.scrollHeight;
        
        currentZoomScale = Math.max(MIN_SCALE, currentZoomScale - SCALE_STEP);
        reRenderAllPages().then(() => {
            container.scrollTop = scrollRatio * container.scrollHeight;
        });
    }
});

const MAX_RENDERED_PAGES = 15;
let renderedPagesQueue = [];

async function renderAllPages() {
    if (!pdfJsDoc) return;

    pdfViewerContainer.innerHTML = '';
    loadingEl.classList.add('hidden');

    const scale = currentZoomScale;

    for (let pageNumber = 1; pageNumber <= totalPages; pageNumber++) {
        const page = await pdfJsDoc.getPage(pageNumber);
        const viewport = page.getViewport({ scale: scale });

        const pageContainer = document.createElement('div');
        pageContainer.className = 'pdf-page-container';
        pageContainer.dataset.pageNumber = pageNumber;
        pageContainer.style.marginBottom = '20px';
        pageContainer.style.position = 'relative';
        pageContainer.style.minHeight = viewport.height + 'px';
        pageContainer.style.width = viewport.width + 'px';

        pdfViewerContainer.appendChild(pageContainer);
        
        if (pageNumber % 50 === 0) {
            await new Promise(resolve => setTimeout(resolve, 0));
        }
    }
    
    setupSmartRendering();
    
    updateCurrentPage();
    pdfViewerContainer.removeEventListener('scroll', updateCurrentPage);
    pdfViewerContainer.addEventListener('scroll', updateCurrentPage);
}

function setupSmartRendering() {
    const observerOptions = {
        root: pdfViewerContainer,
        rootMargin: '1000px',
        threshold: 0
    };

    const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
            const pageNumber = parseInt(entry.target.dataset.pageNumber);

            if (entry.isIntersecting) {
                renderSinglePage(pageNumber);
            } else {
                const rect = entry.target.getBoundingClientRect();
                const viewportHeight = window.innerHeight;
                const distance = Math.min(
                    Math.abs(rect.top),
                    Math.abs(rect.bottom - viewportHeight)
                );
                
                if (distance > 2000) {
                    unrenderSinglePage(pageNumber);
                }
            }
        });
    }, observerOptions);

    document.querySelectorAll('.pdf-page-container').forEach(container => {
        observer.observe(container);
    });
}

async function renderSinglePage(pageNumber) {
    const pageContainer = document.querySelector(`.pdf-page-container[data-page-number="${pageNumber}"]`);
    if (!pageContainer || pageContainer.querySelector('canvas')) return;

    try {
        const page = await pdfJsDoc.getPage(pageNumber);
        const viewport = page.getViewport({ scale: currentZoomScale });

        const canvas = document.createElement('canvas');
        canvas.className = 'pdf-page';
        if (pdfColorMode === 'dark') {
            canvas.classList.add('dark-mode');
        } else if (pdfColorMode === 'grayscale') {
            canvas.classList.add('grayscale-mode');
        }
        const context = canvas.getContext('2d');
        canvas.height = viewport.height;
        canvas.width = viewport.width;

        const textLayerDiv = document.createElement('div');
        textLayerDiv.className = 'textLayer';
        textLayerDiv.style.width = viewport.width + 'px';
        textLayerDiv.style.height = viewport.height + 'px';
        textLayerDiv.style.setProperty('--scale-factor', currentZoomScale);

        pageContainer.appendChild(canvas);
        pageContainer.appendChild(textLayerDiv);

        await page.render({
            canvasContext: context,
            viewport: viewport
        }).promise;

        const textContent = await page.getTextContent();
        pdfjsLib.renderTextLayer({
            textContentSource: textContent,
            container: textLayerDiv,
            viewport: viewport,
            textDivs: []
        });

        renderedPagesQueue.push(pageNumber);
        
        if (renderedPagesQueue.length > MAX_RENDERED_PAGES) {
            const oldestPage = renderedPagesQueue.shift();
            const currentPage = getCurrentVisiblePage();
            
            if (Math.abs(oldestPage - currentPage) > 5) {
                unrenderSinglePage(oldestPage);
            }
        }

    } catch (error) {
        console.error(`Error rendering page ${pageNumber}:`, error);
    }
}

function unrenderSinglePage(pageNumber) {
    const pageContainer = document.querySelector(`.pdf-page-container[data-page-number="${pageNumber}"]`);
    if (!pageContainer) return;

    const canvas = pageContainer.querySelector('canvas');
    const textLayer = pageContainer.querySelector('.textLayer');
    
    if (canvas) {
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        canvas.width = 0;
        canvas.height = 0;
        canvas.remove();
    }
    
    if (textLayer) textLayer.remove();
    
    renderedPagesQueue = renderedPagesQueue.filter(p => p !== pageNumber);
}

async function reRenderAllPages() {
    if (!pdfJsDoc) return;

    const container = pdfViewerContainer;
    const currentPageNum = getCurrentVisiblePage();
    
    renderedPagesQueue = [];
    
    container.innerHTML = '';
    
    const scale = currentZoomScale;

    for (let pageNumber = 1; pageNumber <= totalPages; pageNumber++) {
        const page = await pdfJsDoc.getPage(pageNumber);
        const viewport = page.getViewport({ scale: scale });

        const pageContainer = document.createElement('div');
        pageContainer.className = 'pdf-page-container';
        pageContainer.dataset.pageNumber = pageNumber;
        pageContainer.style.marginBottom = '20px';
        pageContainer.style.position = 'relative';
        pageContainer.style.minHeight = viewport.height + 'px';
        pageContainer.style.width = viewport.width + 'px';

        container.appendChild(pageContainer);
        
        if (pageNumber % 50 === 0) {
            await new Promise(resolve => setTimeout(resolve, 0));
        }
    }
    
    setupSmartRendering();
    
    const pageToScrollTo = document.querySelector(`.pdf-page-container[data-page-number="${currentPageNum}"]`);
    if (pageToScrollTo) {
        pageToScrollTo.scrollIntoView({ block: 'start' });
    }
    
    updateCurrentPage();
}

async function renderPage(pageNumber, scale) {
    const actualScale = scale !== undefined ? scale : currentZoomScale;
    
    if (pageCache.has(pageNumber)) {
        return;
    }

    const pageContainer = document.querySelector(`.pdf-page-container[data-page-number="${pageNumber}"]`);
    if (!pageContainer) return;

    try {
        const page = await pdfJsDoc.getPage(pageNumber);
        const viewport = page.getViewport({ scale: actualScale });

        pageContainer.innerHTML = '';

        const canvas = document.createElement('canvas');
        canvas.className = 'pdf-page';
        if (pdfColorMode === 'dark') {
            canvas.classList.add('dark-mode');
        } else if (pdfColorMode === 'grayscale') {
            canvas.classList.add('grayscale-mode');
        }
        const context = canvas.getContext('2d');
        canvas.height = viewport.height;
        canvas.width = viewport.width;

        const textLayerDiv = document.createElement('div');
        textLayerDiv.className = 'textLayer';
        textLayerDiv.style.width = viewport.width + 'px';
        textLayerDiv.style.height = viewport.height + 'px';
        textLayerDiv.style.setProperty('--scale-factor', scale);

        pageContainer.appendChild(canvas);
        pageContainer.appendChild(textLayerDiv);

        await page.render({
            canvasContext: context,
            viewport: viewport
        }).promise;

        const textContent = await page.getTextContent();
        pdfjsLib.renderTextLayer({
            textContentSource: textContent,
            container: textLayerDiv,
            viewport: viewport,
            textDivs: []
        });

        pageCache.set(pageNumber, true);
        visiblePages.add(pageNumber);

    } catch (error) {
        console.error(`Error rendering page ${pageNumber}:`, error);
    }
}

function unrenderPage(pageNumber) {
    const pageContainer = document.querySelector(`.pdf-page-container[data-page-number="${pageNumber}"]`);
    if (!pageContainer) return;

    const canvas = pageContainer.querySelector('canvas');
    const textLayer = pageContainer.querySelector('.textLayer');
    
    if (canvas) canvas.remove();
    if (textLayer) textLayer.remove();

    pageCache.delete(pageNumber);
    visiblePages.delete(pageNumber);
}

function setupLazyLoading(scale) {
    const observerOptions = {
        root: pdfViewerContainer,
        rootMargin: '500px',
        threshold: 0
    };

    const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
            const pageNumber = parseInt(entry.target.dataset.pageNumber);

            if (entry.isIntersecting) {
                renderPage(pageNumber, scale);
                
                for (let i = 1; i <= PAGES_TO_RENDER_AHEAD; i++) {
                    if (pageNumber + i <= totalPages) {
                        renderPage(pageNumber + i, scale);
                    }
                    if (pageNumber - i >= 1) {
                        renderPage(pageNumber - i, scale);
                    }
                }
            } else {
                const currentPage = getCurrentVisiblePage();
                const distance = Math.abs(pageNumber - currentPage);
                
                if (distance > PAGES_TO_RENDER_AHEAD + 3) {
                    unrenderPage(pageNumber);
                }
            }
        });
    }, observerOptions);

    document.querySelectorAll('.pdf-page-container').forEach(container => {
        observer.observe(container);
    });
}

function getCurrentVisiblePage() {
    const container = pdfViewerContainer;
    const scrollTop = container.scrollTop;
    const containerHeight = container.clientHeight;
    const scrollCenter = scrollTop + (containerHeight / 2);

    let currentPageNum = 1;
    let closestDistance = Infinity;
    
    const pages = document.querySelectorAll('.pdf-page-container');
    
    pages.forEach(page => {
        const pageNum = parseInt(page.dataset.pageNumber);
        const pageTop = page.offsetTop;
        const pageHeight = page.offsetHeight;
        const pageCenter = pageTop + (pageHeight / 2);
        
        const distance = Math.abs(scrollCenter - pageCenter);
        
        if (distance < closestDistance) {
            closestDistance = distance;
            currentPageNum = pageNum;
        }
    });

    return currentPageNum;
}
function updateCurrentPage() {
    currentPage = getCurrentVisiblePage();
    
    const pageDisplay = document.getElementById('currentPageDisplay');
    if (pageDisplay) {
        pageDisplay.innerHTML = `Page ${currentPage}<br>of ${totalPages}`;
    }
    
    const searchIndicator = document.getElementById('searchPageIndicator');
    const searchSection = document.getElementById('pdfSearchSection');
    if (searchIndicator && searchSection && searchSection.style.display === 'block') {
        searchIndicator.textContent = `${currentPage}/${totalPages}`;
    }
}

function getPageFromSelection() {
    const selection = window.getSelection();
    if (!selection.rangeCount) return currentPage;

    const range = selection.getRangeAt(0);
    const container = range.startContainer;

    let element = container.parentElement;
    while (element) {
        if (element.classList && element.classList.contains('pdf-page-container')) {
            return parseInt(element.dataset.pageNumber);
        }
        element = element.parentElement;
    }

    return currentPage;
}

document.getElementById('selectInvertPages').addEventListener('click', () => {
    const newSelection = new Set();
    
    pageEditorState.reorderedPages.forEach((page, index) => {
        if (!page.deleted && !pageEditorState.selectedPages.has(index)) {
            newSelection.add(index);
        }
    });
    
    pageEditorState.selectedPages = newSelection;
    syncCheckboxes();
    updateSelectionInfo();
});

document.getElementById('clearSearch').addEventListener('click', () => {
    pdfSearchBox.value = '';
    searchResults.innerHTML = '';
    searchStatus.textContent = pdfSearchChunks.length ? 
        `${pdfSearchChunks.length} chunks indexed ‚Ä¢ ${totalPages} pages` : '';
    pdfSearchBox.focus();
});

pdfInput.addEventListener('change', async (e) => {
    const file = e.target.files[0];
    if (!file) return;
    
    await loadPdfFile(file);
});

const loadExistingBtn = document.getElementById('loadExistingBtn');

loadExistingBtn.addEventListener('click', async () => {
    if (!pdfDoc) {
        showToast('No PDF loaded', 'error');
        return;
    }

    try {
        const existingBookmarks = await extractExistingBookmarks(pdfDoc);
        
        if (existingBookmarks.length === 0) {
            showToast('No existing bookmarks found in PDF', 'info');
            return;
        }
        
        const shouldReplace = confirm(
            `Found ${existingBookmarks.length} existing bookmarks.\n\n` +
            `Click OK to REPLACE current bookmarks (${bookmarks.length})\n` +
            `Click Cancel to MERGE with current bookmarks`
        );
        
        if (shouldReplace) {
            bookmarks = existingBookmarks;
            showToast(`Loaded ${existingBookmarks.length} bookmarks`, 'success');
        } else {
            let addedCount = 0;
            existingBookmarks.forEach(existing => {
                const duplicate = bookmarks.find(b => 
                    b.page === existing.page && b.title === existing.title
                );
                if (!duplicate) {
                    bookmarks.push(existing);
                    addedCount++;
                }
            });
            bookmarks.sort((a, b) => a.page - b.page);
            const skipped = existingBookmarks.length - addedCount;
            showToast(`Merged ${addedCount} bookmarks${skipped > 0 ? ` (${skipped} duplicates skipped)` : ''}`, 'success');
        }
        
        renderBookmarks();
        
    } catch (error) {
        showToast('Error loading bookmarks: ' + error.message, 'error');
        console.error(error);
    }
});

function cleanBookmarkTitle(title) {
    return title
        .replace(/‚ûù|‚Üí|‚ûî|‚ûû|‚ûü|‚û†|‚û°|‚û¢|‚û£|‚û§|‚û•|‚û¶|‚ûß|‚û®/g, '->') 
        .replace(/≈°/g, 's')
        .replace(/≈æ/g, 'z')
        .replace(/['']/g, "'")
        .replace(/[""]/g, '"')
        .replace(/[‚Äî‚Äì]/g, '-')
        .replace(/‚Ä¶/g, '...')
        .replace(/[\u2000-\u206F]/g, ' ')  // General punctuation spaces
        .replace(/[\u2190-\u21FF]/g, '->')  // All arrow characters
        .replace(/[^\x00-\x7F]/g, (char) => {
            // For any remaining non-ASCII, try to keep if it's common
            const code = char.charCodeAt(0);
            if (code < 256) return char;  // Keep Latin-1 supplement
            return ''; 
        })
        .replace(/\s+/g, ' ')
        .trim();
}

function addBookmark(level = 1) {
    let title = '';
    let selectedText = window.getSelection().toString().trim();
    
    if (selectedText) {
        title = selectedText.replace(/\n+/g, ' ').replace(/\s+/g, ' ').trim();
        if (title.length > 100) {
            title = title.substring(0, 100);
        }
        title = cleanBookmarkTitle(title);
    } else {
        const labels = { 1: 'Chapter', 2: 'Section', 3: 'Subsection' };
        title = labels[level];
    }

    const pageNumber = getPageFromSelection();

    const bookmark = {
        id: Date.now() + Math.random(),
        title: title,
        page: pageNumber,
        level: level
    };
    
    bookmarks.push(bookmark);
    
    bookmarks.sort((a, b) => a.page - b.page);
    
    renderBookmarks();
    
    scrollToBookmark(bookmark.id);
    
    showToast(`Added ${level === 1 ? 'Chapter' : level === 2 ? 'Section' : 'Subsection'} on page ${pageNumber}`, 'success');
}

function scrollToBookmark(bookmarkId) {
    setTimeout(() => {
        const bookmarkElements = bookmarksList.querySelectorAll('.bookmark-item');
        
        bookmarkElements.forEach(el => {
            const input = el.querySelector('input[data-id]');
            if (input && parseFloat(input.dataset.id) === bookmarkId) {
                el.scrollIntoView({ 
                    behavior: 'smooth', 
                    block: 'center' 
                });
                
                el.classList.add('newly-added');
                setTimeout(() => {
                    el.classList.remove('newly-added');
                }, 600);
            }
        });
    }, 100);
}

document.addEventListener('keydown', (e) => {
    const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
    const modifier = isMac ? e.metaKey : e.ctrlKey;

    if (modifier && e.key === 'a') {
        e.preventDefault();
        addBookmark(1);
    } else if (modifier && e.key === 's') {
        e.preventDefault();
        addBookmark(2);
    } else if (modifier && e.key === 'd') {
        e.preventDefault();
        addBookmark(3);
    }
});

function deleteBookmark(id) {
    bookmarks = bookmarks.filter(b => b.id !== id);
    renderBookmarks();
}

function titleCaseBookmark(id) {
    const bookmark = bookmarks.find(b => b.id === id);
    if (!bookmark || !bookmark.title) return;
    
    if (lastTitleCaseOperation && 
        lastTitleCaseOperation.id === id && 
        bookmark.title === lastTitleCaseOperation.newTitle) {
        bookmark.title = lastTitleCaseOperation.oldTitle;
        lastTitleCaseOperation = null;
        showToast('Title case undone', 'info');
    } else {
        const oldTitle = bookmark.title;
        const newTitle = toTitleCase(bookmark.title);
        bookmark.title = newTitle;
        
        lastTitleCaseOperation = {
            id: id,
            oldTitle: oldTitle,
            newTitle: newTitle
        };
        
        showToast('Title case applied', 'success');
    }
    
    renderBookmarks();
}

function scrollToPage(pageNumber) {
    const pageContainer = document.querySelector(`.pdf-page-container[data-page-number="${pageNumber}"]`);
    if (pageContainer) {
        pageContainer.scrollIntoView({ 
            behavior: 'smooth', 
            block: 'start' 
        });
        
        currentPage = pageNumber;
        updateCurrentPage();
        
        pageContainer.style.outline = '3px solid rgba(102, 126, 234, 0.6)';
        setTimeout(() => {
            pageContainer.style.outline = '';
        }, 1000);
        
        showToast(`Navigated to page ${pageNumber}`, 'info', 5000);
    }
}

function renderBookmarks() {
    if (bookmarks.length === 0) {
        bookmarksList.innerHTML = `
            <div class="empty-state">
                <p>No bookmarks yet</p>
                <p style="margin-top: 10px; font-size: 13px;">
                    Select text in PDF and use keyboard shortcuts
                </p>
            </div>
        `;
        return;
    }

    bookmarks.sort((a, b) => a.page - b.page);

    bookmarksList.innerHTML = '';
    
    bookmarks.forEach(bookmark => {
        const div = document.createElement('div');
        div.className = `bookmark-item level-${bookmark.level}`;
        
        const levelLabels = { 1: 'Chapter', 2: 'Section', 3: 'Subsection' };
        
        div.innerHTML = `
            <div class="bookmark-item-header">
                <div class="bookmark-header-left">
                    <span class="bookmark-page clickable" data-page="${bookmark.page}">Page ${bookmark.page}</span>
                    <span style="color: #888; font-size: 12px;">${levelLabels[bookmark.level]}</span>
                </div>
                <div class="bookmark-actions">
                    <button class="btn btn-secondary btn-small ${lastTitleCaseOperation && lastTitleCaseOperation.id === bookmark.id ? 'undo-available' : ''}" data-id="${bookmark.id}" data-action="titlecase" title="${lastTitleCaseOperation && lastTitleCaseOperation.id === bookmark.id ? 'Click to undo' : 'Apply title case'}">Aa</button>
                    <button class="btn btn-delete btn-small" data-id="${bookmark.id}" data-action="delete">üóëÔ∏è</button>
                </div>
            </div>
            <input 
                type="text" 
                placeholder="Bookmark title" 
                value="${bookmark.title}"
                data-id="${bookmark.id}"
                data-field="title"
            />
        `;
        
        bookmarksList.appendChild(div);
    });
    
    bookmarksList.querySelectorAll('.bookmark-page.clickable').forEach(pageEl => {
        pageEl.addEventListener('click', (e) => {
            const pageNumber = parseInt(e.target.dataset.page);
            scrollToPage(pageNumber);
        });
    });
    
    bookmarksList.querySelectorAll('input').forEach(input => {
        input.addEventListener('input', (e) => {
            const id = parseFloat(e.target.dataset.id);
            const bookmark = bookmarks.find(b => b.id === id);
            if (bookmark) {
                bookmark.title = e.target.value;
                
                if (lastTitleCaseOperation && lastTitleCaseOperation.id === id) {
                    lastTitleCaseOperation = null;
                }
            }
        });
    });
    
    bookmarksList.querySelectorAll('button[data-action]').forEach(btn => {
        btn.addEventListener('click', (e) => {
            const id = parseFloat(e.target.dataset.id);
            const action = e.target.dataset.action;
            
            if (action === 'delete') {
                deleteBookmark(id);
            } else if (action === 'titlecase') {
                titleCaseBookmark(id);
            }
        });
    });
}

importInput.addEventListener('change', async (e) => {
    const file = e.target.files[0];
    if (!file) return;

    try {
        const text = await file.text();
        const lines = text.split('\n');
        
        bookmarks = [];
        
        lines.forEach(line => {
            line = line.trim();
            if (!line) return;
            
            const match = line.match(/"([^"]+)"\s+(\d+)\s+(\d+)/);
            if (match) {
                bookmarks.push({
                    id: Date.now() + Math.random(),
                    title: match[1],
                    page: parseInt(match[2]),
                    level: parseInt(match[3])
                });
            }
        });
        
        renderBookmarks();
        showToast(`Imported ${bookmarks.length} bookmarks`, 'success');
    } catch (error) {
        showToast('Error importing bookmarks: ' + error.message, 'error');
        console.error(error);
    }

    importInput.value = '';
});

exportBtn.addEventListener('click', () => {
    if (bookmarks.length === 0) {
        showToast('No bookmarks to export', 'error');
        return;
    }

    const content = bookmarks
        .map(b => `"${b.title}" ${b.page} ${b.level}`)
        .join('\n');
    
    const blob = new Blob([content], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'bookmarks.txt';
    a.click();
    URL.revokeObjectURL(url);
    
    showToast('Bookmarks exported', 'success');
});

applyBookmarksBtn.addEventListener('click', async () => {
    if (!originalFile) {
        showToast('No PDF loaded', 'error');
        return;
    }

    if (bookmarks.length === 0) {
        showToast('No bookmarks to apply', 'error');
        return;
    }

    try {
        showToast('Creating PDF with bookmarks...', 'info');

        const freshArrayBuffer = await originalFile.arrayBuffer();
        const freshPdfBytes = new Uint8Array(freshArrayBuffer);
        const newPdfDoc = await PDFDocument.load(freshPdfBytes, { ignoreEncryption: true });
        

        let maxLevel = 1;
        for (let bookmark of bookmarks) {
            bookmark.title = cleanBookmarkTitle(bookmark.title);
            
            if (bookmark.level > maxLevel + 1) {
                bookmark.level = maxLevel + 1;
            }
            maxLevel = Math.max(maxLevel, bookmark.level);
        }

        const sortedBookmarks = [...bookmarks].sort((a, b) => a.page - b.page);

        const context = newPdfDoc.context;
        const outlinesRef = context.nextRef();
        const outlines = context.obj({
            Type: 'Outlines',
        });

        const itemRefs = [];
        const items = [];

        sortedBookmarks.forEach((bookmark) => {
            const page = newPdfDoc.getPage(bookmark.page - 1);
            const itemRef = context.nextRef();
            itemRefs.push(itemRef);

            const item = {
                Title: PDFString.of(bookmark.title),
                Parent: outlinesRef,
                Dest: [
                    page.ref,
                    'XYZ',
                    null,
                    null,
                    null
                ]
            };

            items.push(item);
        });

        items.forEach((item, index) => {
            if (index > 0) {
                item.Prev = itemRefs[index - 1];
            }
            if (index < items.length - 1) {
                item.Next = itemRefs[index + 1];
            }
        });

        items.forEach((item, index) => {
            context.assign(itemRefs[index], context.obj(item));
        });

        if (itemRefs.length > 0) {
            outlines.set(PDFName.of('First'), itemRefs[0]);
            outlines.set(PDFName.of('Last'), itemRefs[itemRefs.length - 1]);
            outlines.set(PDFName.of('Count'), PDFNumber.of(itemRefs.length));
        }

        context.assign(outlinesRef, outlines);
        newPdfDoc.catalog.set(PDFName.of('Outlines'), outlinesRef);

        const pdfBytesWithBookmarks = await newPdfDoc.save();

        const blob = new Blob([pdfBytesWithBookmarks], { type: 'application/pdf' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = pdfFileName.replace('.pdf', '_bookmarked.pdf');
        a.click();
        URL.revokeObjectURL(url);

        showToast('PDF with bookmarks created successfully!', 'success');

    } catch (error) {
        showToast('Error creating PDF: ' + error.message, 'error');
        console.error('Full error:', error);
    }
});

renderBookmarks();

let pageEditorState = {
    pages: [],
    selectedPages: new Set(),
    rotations: new Map(),
    deletedPages: new Set(),
    reorderedPages: []
};

const openPageEditorBtn = document.getElementById('openPageEditor');
const pageEditorModal = document.getElementById('pageEditorModal');
const closePageEditorBtn = document.getElementById('closePageEditor');
const pageGrid = document.getElementById('pageGrid');
const selectionCount = document.getElementById('selectionCount');

openPageEditorBtn.addEventListener('click', async () => {
    if (!pdfDoc || !pdfJsDoc) {
        showToast('No PDF loaded', 'error');
        return;
    }

    showToast('Loading page editor...', 'info');
    
    pageEditorState = {
        pages: [],
        selectedPages: new Set(),
        rotations: new Map(),
        deletedPages: new Set(),
        reorderedPages: []
    };
    
    undoStack = [];
    updateUndoButton();

    for (let i = 1; i <= totalPages; i++) {
        pageEditorState.pages.push({
            number: i,
            rotation: 0,
            deleted: false
        });
    }

    pageEditorState.reorderedPages = [...pageEditorState.pages];

    await renderPageGrid();
    pageEditorModal.classList.remove('hidden');
    updateSelectionInfo();
});

closePageEditorBtn.addEventListener('click', () => {
    pageEditorModal.classList.add('hidden');
});

document.getElementById('cancelPageEdit').addEventListener('click', () => {
    pageEditorModal.classList.add('hidden');
});

async function renderPageGrid() {
    pageGrid.innerHTML = '<div style="grid-column: 1/-1; text-align: center; padding: 40px; color: #888;">Loading thumbnails...</div>';

    const thumbnails = [];

    for (let i = 0; i < pageEditorState.reorderedPages.length; i++) {
        const pageData = pageEditorState.reorderedPages[i];
        if (pageData.deleted) continue;

        const page = await pdfJsDoc.getPage(pageData.number);
        const scale = 0.5;
        const viewport = page.getViewport({ scale, rotation: pageData.rotation });

        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        canvas.height = viewport.height;
        canvas.width = viewport.width;

        await page.render({
            canvasContext: context,
            viewport: viewport
        }).promise;

        thumbnails.push({
            canvas,
            pageData,
            index: i,
            viewport
        });
    }

    pageGrid.innerHTML = '';

    thumbnails.forEach(({ canvas, pageData, index, viewport }) => {
        const div = document.createElement('div');
        div.className = pageData.deleted ? 'page-thumbnail deleted' : 'page-thumbnail';
        div.dataset.index = index;
        div.draggable = !pageData.deleted;
    
        const rotation = pageData.rotation !== 0 ? `<span class="rotation-indicator">${pageData.rotation}¬∞</span>` : '';
        
        const actualWidth = Math.round(viewport.width * 2);
        const actualHeight = Math.round(viewport.height * 2);
        
        div.innerHTML = `
            <input type="checkbox" class="page-checkbox" data-index="${index}" ${pageData.deleted ? 'disabled' : ''}>
            ${rotation}
            <canvas class="page-thumbnail-canvas"></canvas>
            <div class="page-thumbnail-info">
                <span class="page-number">Page ${pageData.number}</span>
                <span class="page-size">${actualWidth} √ó ${actualHeight}</span>
            </div>
        `;
    
        const thumbnailCanvas = div.querySelector('.page-thumbnail-canvas');
        const ctx = thumbnailCanvas.getContext('2d');
        thumbnailCanvas.width = canvas.width;
        thumbnailCanvas.height = canvas.height;
        ctx.drawImage(canvas, 0, 0);
    
        pageGrid.appendChild(div);
    });

    setupPageGridEvents();
}

function setupPageGridEvents() {
    pageGrid.querySelectorAll('.page-checkbox').forEach(checkbox => {
        checkbox.addEventListener('change', (e) => {
            const index = parseInt(e.target.dataset.index);
            if (e.target.checked) {
                pageEditorState.selectedPages.add(index);
                e.target.closest('.page-thumbnail').classList.add('selected');
            } else {
                pageEditorState.selectedPages.delete(index);
                e.target.closest('.page-thumbnail').classList.remove('selected');
            }
            updateSelectionInfo();
        });
    });

    pageGrid.querySelectorAll('.page-thumbnail').forEach(thumb => {
        thumb.addEventListener('click', (e) => {
            if (e.target.classList.contains('page-checkbox')) return;
            const checkbox = thumb.querySelector('.page-checkbox');
            checkbox.checked = !checkbox.checked;
            checkbox.dispatchEvent(new Event('change'));
        });
    });

    const thumbnails = pageGrid.querySelectorAll('.page-thumbnail');
    thumbnails.forEach(thumb => {
        thumb.addEventListener('dragstart', handlePageDragStart);
        thumb.addEventListener('dragover', handlePageDragOver);
        thumb.addEventListener('drop', handlePageDrop);
        thumb.addEventListener('dragend', handlePageDragEnd);
        thumb.addEventListener('dragenter', handlePageDragEnter);
        thumb.addEventListener('dragleave', handlePageDragLeave);
    });
}

let draggedPageElement = null;

function handlePageDragStart(e) {
    draggedPageElement = this;
    this.classList.add('dragging');
    e.dataTransfer.effectAllowed = 'move';
}

function handlePageDragOver(e) {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';
    return false;
}

function handlePageDragEnter(e) {
    if (this !== draggedPageElement) {
        this.classList.add('drag-over');
    }
}

function handlePageDragLeave(e) {
    this.classList.remove('drag-over');
}

function handlePageDrop(e) {
    e.stopPropagation();
    e.preventDefault();

    if (draggedPageElement !== this) {
        const fromIndex = parseInt(draggedPageElement.dataset.index);
        const toIndex = parseInt(this.dataset.index);

        saveUndoState('Reorder Pages');

        const container = document.getElementById('pageGridContainer');
        const scrollPos = container.scrollTop;

        const movedPage = pageEditorState.reorderedPages.splice(fromIndex, 1)[0];
        pageEditorState.reorderedPages.splice(toIndex, 0, movedPage);

        const fromElement = pageGrid.querySelector(`[data-index="${fromIndex}"]`);
        const toElement = pageGrid.querySelector(`[data-index="${toIndex}"]`);
        
        if (fromIndex < toIndex) {
            toElement.parentNode.insertBefore(fromElement, toElement.nextSibling);
        } else {
            toElement.parentNode.insertBefore(fromElement, toElement);
        }

        const thumbnails = pageGrid.querySelectorAll('.page-thumbnail');
        thumbnails.forEach((thumb, newIndex) => {
            thumb.dataset.index = newIndex;
            const checkbox = thumb.querySelector('.page-checkbox');
            if (checkbox) {
                checkbox.dataset.index = newIndex;
            }
        });

        const newSelectedPages = new Set();
        pageEditorState.selectedPages.forEach(oldIndex => {
            if (oldIndex === fromIndex) {
                newSelectedPages.add(toIndex);
            } else if (fromIndex < toIndex) {
                if (oldIndex > fromIndex && oldIndex <= toIndex) {
                    newSelectedPages.add(oldIndex - 1);
                } else {
                    newSelectedPages.add(oldIndex);
                }
            } else {
                if (oldIndex >= toIndex && oldIndex < fromIndex) {
                    newSelectedPages.add(oldIndex + 1);
                } else {
                    newSelectedPages.add(oldIndex);
                }
            }
        });
        pageEditorState.selectedPages = newSelectedPages;

        container.scrollTop = scrollPos;
        syncCheckboxes();
    }

    return false;
}

function handlePageDragEnd(e) {
    pageGrid.querySelectorAll('.page-thumbnail').forEach(thumb => {
        thumb.classList.remove('dragging');
        thumb.classList.remove('drag-over');
    });
}

document.getElementById('selectAllPages').addEventListener('click', () => {
    pageEditorState.selectedPages.clear();
    pageEditorState.reorderedPages.forEach((_, index) => {
        pageEditorState.selectedPages.add(index);
    });
    pageGrid.querySelectorAll('.page-checkbox').forEach(cb => {
        cb.checked = true;
        cb.closest('.page-thumbnail').classList.add('selected');
    });
    updateSelectionInfo();
});

document.getElementById('selectNonePages').addEventListener('click', () => {
    pageEditorState.selectedPages.clear();
    pageGrid.querySelectorAll('.page-checkbox').forEach(cb => {
        cb.checked = false;
        cb.closest('.page-thumbnail').classList.remove('selected');
    });
    updateSelectionInfo();
});

document.getElementById('selectEvenPages').addEventListener('click', () => {
    pageEditorState.selectedPages.clear();
    pageEditorState.reorderedPages.forEach((page, index) => {
        if (page.number % 2 === 0) {
            pageEditorState.selectedPages.add(index);
        }
    });
    syncCheckboxes();
    updateSelectionInfo();
});

document.getElementById('selectOddPages').addEventListener('click', () => {
    pageEditorState.selectedPages.clear();
    pageEditorState.reorderedPages.forEach((page, index) => {
        if (page.number % 2 === 1) {
            pageEditorState.selectedPages.add(index);
        }
    });
    syncCheckboxes();
    updateSelectionInfo();
});

document.getElementById('selectRange').addEventListener('click', () => {
    const rangeInput = document.getElementById('splitRangeInput').value.trim();
    if (!rangeInput) {
        showToast('Enter page range (e.g., 1-5, 10, 15-20)', 'error');
        return;
    }

    try {
        const pageNumbers = parsePageRange(rangeInput);
        if (pageNumbers.length === 0) {
            showToast('Invalid page range', 'error');
            return;
        }

        pageEditorState.selectedPages.clear();

        pageEditorState.reorderedPages.forEach((page, index) => {
            if (!page.deleted && pageNumbers.includes(page.number)) {
                pageEditorState.selectedPages.add(index);
            }
        });

        syncCheckboxes();
        updateSelectionInfo();
        
        showToast(`Selected ${pageEditorState.selectedPages.size} page(s)`, 'success');

    } catch (error) {
        showToast('Error parsing range: ' + error.message, 'error');
    }
});

function syncCheckboxes() {
    pageGrid.querySelectorAll('.page-checkbox').forEach(cb => {
        const index = parseInt(cb.dataset.index);
        cb.checked = pageEditorState.selectedPages.has(index);
        if (cb.checked) {
            cb.closest('.page-thumbnail').classList.add('selected');
        } else {
            cb.closest('.page-thumbnail').classList.remove('selected');
        }
    });
}

document.getElementById('rotateLeft').addEventListener('click', async () => {
    if (pageEditorState.selectedPages.size === 0) {
        showToast('No pages selected', 'error');
        return;
    }
    
    saveUndoState('Rotate Left');
    
    const indicesToUpdate = Array.from(pageEditorState.selectedPages);
    
    for (const index of indicesToUpdate) {
        const page = pageEditorState.reorderedPages[index];
        page.rotation = (page.rotation - 90 + 360) % 360;
        await updateSingleThumbnail(index);
    }
    
    showToast(`Rotated ${pageEditorState.selectedPages.size} page(s) left`, 'success');
});

document.getElementById('rotateRight').addEventListener('click', async () => {
    if (pageEditorState.selectedPages.size === 0) {
        showToast('No pages selected', 'error');
        return;
    }
    
    saveUndoState('Rotate Right');
    
    const indicesToUpdate = Array.from(pageEditorState.selectedPages);
    
    for (const index of indicesToUpdate) {
        const page = pageEditorState.reorderedPages[index];
        page.rotation = (page.rotation + 90) % 360;
        await updateSingleThumbnail(index);
    }
    
    showToast(`Rotated ${pageEditorState.selectedPages.size} page(s) right`, 'success');
});

document.getElementById('rotate180').addEventListener('click', async () => {
    if (pageEditorState.selectedPages.size === 0) {
        showToast('No pages selected', 'error');
        return;
    }
    
    saveUndoState('Rotate 180¬∞');
    
    const indicesToUpdate = Array.from(pageEditorState.selectedPages);
    
    for (const index of indicesToUpdate) {
        const page = pageEditorState.reorderedPages[index];
        page.rotation = (page.rotation + 180) % 360;
        await updateSingleThumbnail(index);
    }
    
    showToast(`Rotated ${pageEditorState.selectedPages.size} page(s) 180¬∞`, 'success');
});

async function updateSingleThumbnail(index) {
    const pageData = pageEditorState.reorderedPages[index];
    const thumbnail = pageGrid.querySelector(`[data-index="${index}"]`);
    if (!thumbnail || pageData.deleted) return;

    const page = await pdfJsDoc.getPage(pageData.number);
    const scale = 0.5;
    const viewport = page.getViewport({ scale, rotation: pageData.rotation });

    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d');
    canvas.height = viewport.height;
    canvas.width = viewport.width;

    await page.render({
        canvasContext: context,
        viewport: viewport
    }).promise;

    const thumbnailCanvas = thumbnail.querySelector('.page-thumbnail-canvas');
    thumbnailCanvas.width = canvas.width;
    thumbnailCanvas.height = canvas.height;
    const ctx = thumbnailCanvas.getContext('2d');
    ctx.drawImage(canvas, 0, 0);

    const oldIndicator = thumbnail.querySelector('.rotation-indicator');
    if (oldIndicator) oldIndicator.remove();
    
    if (pageData.rotation !== 0) {
        const indicator = document.createElement('span');
        indicator.className = 'rotation-indicator';
        indicator.textContent = `${pageData.rotation}¬∞`;
        thumbnail.insertBefore(indicator, thumbnail.querySelector('.page-thumbnail-canvas'));
    }

    const actualWidth = Math.round(viewport.width * 2);
    const actualHeight = Math.round(viewport.height * 2);
    const sizeSpan = thumbnail.querySelector('.page-size');
    if (sizeSpan) {
        sizeSpan.textContent = `${actualWidth} √ó ${actualHeight}`;
    }
}

document.getElementById('deleteSelected').addEventListener('click', () => {
    if (pageEditorState.selectedPages.size === 0) {
        showToast('No pages selected', 'error');
        return;
    }
    
    const remainingPages = pageEditorState.reorderedPages.filter(p => !p.deleted).length - pageEditorState.selectedPages.size;
    if (remainingPages === 0) {
        showToast('Cannot delete all pages', 'error');
        return;
    }

    if (!confirm(`Delete ${pageEditorState.selectedPages.size} page(s)?`)) {
        return;
    }

    saveUndoState('Delete Pages');

    const indicesToDelete = Array.from(pageEditorState.selectedPages);
    indicesToDelete.forEach(index => {
        pageEditorState.reorderedPages[index].deleted = true;
        
        const thumbnail = pageGrid.querySelector(`[data-index="${index}"]`);
        if (thumbnail) {
            thumbnail.classList.add('deleted');
            const checkbox = thumbnail.querySelector('.page-checkbox');
            if (checkbox) {
                checkbox.checked = false;
                checkbox.disabled = true;
            }
        }
    });

    pageEditorState.selectedPages.clear();
    updateSelectionInfo();
    
    showToast(`Marked ${indicesToDelete.length} page(s) for deletion`, 'success');
});

document.getElementById('splitExtract').addEventListener('click', async () => {
    const rangeInput = document.getElementById('splitRangeInput').value.trim();
    if (!rangeInput) {
        showToast('Enter page range (e.g., 1-5, 10, 15-20)', 'error');
        return;
    }

    try {
        const pageNumbers = parsePageRange(rangeInput);
        if (pageNumbers.length === 0) {
            showToast('Invalid page range', 'error');
            return;
        }

        showToast('Extracting pages...', 'info');

        const newPdf = await PDFDocument.create();
        
        for (const pageNum of pageNumbers) {
            if (pageNum < 1 || pageNum > totalPages) {
                showToast(`Page ${pageNum} out of range`, 'error');
                return;
            }
            const [copiedPage] = await newPdf.copyPages(pdfDoc, [pageNum - 1]);
            newPdf.addPage(copiedPage);
        }

        const pdfBytes = await newPdf.save();
        const blob = new Blob([pdfBytes], { type: 'application/pdf' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = pdfFileName.replace('.pdf', `_pages_${rangeInput.replace(/[,\s]/g, '_')}.pdf`);
        a.click();
        URL.revokeObjectURL(url);

        showToast(`Extracted ${pageNumbers.length} page(s)`, 'success');
        document.getElementById('splitRangeInput').value = '';

    } catch (error) {
        showToast('Error extracting pages: ' + error.message, 'error');
        console.error(error);
    }
});

function parsePageRange(rangeStr) {
    const pages = new Set();
    const parts = rangeStr.split(',');
    
    for (const part of parts) {
        const trimmed = part.trim();
        if (trimmed.includes('-')) {
            const [start, end] = trimmed.split('-').map(s => parseInt(s.trim()));
            if (isNaN(start) || isNaN(end)) continue;
            for (let i = Math.min(start, end); i <= Math.max(start, end); i++) {
                pages.add(i);
            }
        } else {
            const num = parseInt(trimmed);
            if (!isNaN(num)) {
                pages.add(num);
            }
        }
    }
    
    return Array.from(pages).sort((a, b) => a - b);
}

function updateSelectionInfo() {
    const count = pageEditorState.selectedPages.size;
    selectionCount.textContent = count === 0 ? 'No pages selected' : 
                                 count === 1 ? '1 page selected' : 
                                 `${count} pages selected`;
}

document.getElementById('applyPageChanges').addEventListener('click', async () => {
    try {
        showToast('Applying changes...', 'info');

        const newPdf = await PDFDocument.create();
        
        const finalPages = pageEditorState.reorderedPages.filter(p => !p.deleted);
        
        if (finalPages.length === 0) {
            showToast('Cannot create PDF with no pages', 'error');
            return;
        }

        for (const pageData of finalPages) {
            const [copiedPage] = await newPdf.copyPages(pdfDoc, [pageData.number - 1]);
            
            if (pageData.rotation !== 0) {
                copiedPage.setRotation({ angle: pageData.rotation, type: 'degrees' });
            }
            
            newPdf.addPage(copiedPage);
        }

        if (bookmarks.length > 0) {
            const pageMapping = new Map();
            finalPages.forEach((pageData, newIndex) => {
                pageMapping.set(pageData.number, newIndex + 1);
            });

            const adjustedBookmarks = bookmarks
                .filter(b => pageMapping.has(b.page))
                .map(b => ({
                    ...b,
                    page: pageMapping.get(b.page)
                }));

            if (adjustedBookmarks.length > 0) {
                const context = newPdf.context;
                const outlinesRef = context.nextRef();
                const outlines = context.obj({ Type: 'Outlines' });

                const itemRefs = [];
                const items = [];

                adjustedBookmarks.forEach((bookmark) => {
                    const page = newPdf.getPage(bookmark.page - 1);
                    const itemRef = context.nextRef();
                    itemRefs.push(itemRef);

                    items.push({
                        Title: PDFString.of(cleanBookmarkTitle(bookmark.title)),
                        Parent: outlinesRef,
                        Dest: [page.ref, 'XYZ', null, null, null]
                    });
                });

                items.forEach((item, index) => {
                    if (index > 0) item.Prev = itemRefs[index - 1];
                    if (index < items.length - 1) item.Next = itemRefs[index + 1];
                });

                items.forEach((item, index) => {
                    context.assign(itemRefs[index], context.obj(item));
                });

                if (itemRefs.length > 0) {
                    outlines.set(PDFName.of('First'), itemRefs[0]);
                    outlines.set(PDFName.of('Last'), itemRefs[itemRefs.length - 1]);
                    outlines.set(PDFName.of('Count'), PDFNumber.of(itemRefs.length));
                }

                context.assign(outlinesRef, outlines);
                newPdf.catalog.set(PDFName.of('Outlines'), outlinesRef);
            }
        }

        const pdfBytes = await newPdf.save();
        const blob = new Blob([pdfBytes], { type: 'application/pdf' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = pdfFileName.replace('.pdf', '_edited.pdf');
        a.click();
        URL.revokeObjectURL(url);

        showToast(`PDF saved with ${finalPages.length} page(s)`, 'success');
        pageEditorModal.classList.add('hidden');

    } catch (error) {
        showToast('Error applying changes: ' + error.message, 'error');
        console.error(error);
    }
});

if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
        navigator.serviceWorker.register('./service-worker.js')
            .then((registration) => {
                console.log('ServiceWorker registered:', registration.scope);
            })
            .catch((error) => {
                console.log('ServiceWorker registration failed:', error);
            });
    });
}

let pdfSearchIndex = null;
let pdfSearchChunks = [];
let searchTimeout = null;

const openSearchBtn = document.getElementById('openSearchBtn');
const pdfSearchSection = document.getElementById('pdfSearchSection');
const closeSearchBtn = document.getElementById('closeSearch');
const pdfSearchBox = document.getElementById('pdfSearchBox');
const searchResults = document.getElementById('searchResults');
const searchStatus = document.getElementById('searchStatus');

openSearchBtn.addEventListener('click', () => {
    pdfSearchSection.style.display = 'block';
    pdfSearchBox.focus();
    
    const searchIndicator = document.getElementById('searchPageIndicator');
    if (searchIndicator) {
        searchIndicator.textContent = `${currentPage}/${totalPages}`;
    }
});

closeSearchBtn.addEventListener('click', () => {
    pdfSearchSection.style.display = 'none';
    pdfSearchBox.value = '';
    searchResults.innerHTML = '';
    searchStatus.textContent = '';
});

async function buildSearchIndex() {
    if (!pdfJsDoc) return;

    searchStatus.textContent = 'Building search index...';
    pdfSearchChunks = [];
    
    pdfSearchIndex = new MiniSearch({
        fields: ['text'],
        storeFields: ['page', 'text', 'preview'],
        searchOptions: {
            boost: { text: 2 },
            fuzzy: 0.2,
            prefix: true
        }
    });

    let chunkId = 1;

    for (let pageNum = 1; pageNum <= totalPages; pageNum++) {
        const page = await pdfJsDoc.getPage(pageNum);
        const textContent = await page.getTextContent();
        
        let pageText = textContent.items.map(item => item.str).join(' ');
        pageText = pageText.replace(/\s+/g, ' ').trim();

        const chunkSize = 200;
        const overlap = 50;
        
        for (let i = 0; i < pageText.length; i += chunkSize - overlap) {
            const chunk = pageText.substring(i, i + chunkSize);
            if (chunk.trim().length > 30) {
                const doc = {
                    id: chunkId++,
                    text: chunk.toLowerCase(),
                    page: pageNum,
                    preview: chunk.substring(0, 300)
                };
                pdfSearchChunks.push(doc);
            }
        }

        if (pageNum % 10 === 0) {
            searchStatus.textContent = `Indexing page ${pageNum}/${totalPages}...`;
            await new Promise(resolve => setTimeout(resolve, 0));
        }
    }

    pdfSearchIndex.addAll(pdfSearchChunks);
    searchStatus.textContent = `${pdfSearchChunks.length} chunks indexed ‚Ä¢ ${totalPages} pages`;
    openSearchBtn.disabled = false;
}

pdfSearchBox.addEventListener('input', (e) => {
    clearTimeout(searchTimeout);
    const query = e.target.value.trim();
    
    if (query.length < 3) {
        searchResults.innerHTML = '';
        searchStatus.textContent = pdfSearchChunks.length ? 
            `${pdfSearchChunks.length} chunks indexed ‚Ä¢ ${totalPages} pages` : '';
        return;
    }

    searchTimeout = setTimeout(() => {
        performSearch(query);
    }, 300);
});

pdfSearchBox.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
        e.preventDefault();
        const query = pdfSearchBox.value.trim();
        
        if (query.length >= 3) {
            clearTimeout(searchTimeout);
            performSearch(query);
        } else {
            searchResults.innerHTML = '';
            searchStatus.textContent = pdfSearchChunks.length ? 
                `${pdfSearchChunks.length} chunks indexed ‚Ä¢ ${totalPages} pages` : '';
        }
    }
});

document.addEventListener('keydown', (e) => {
    if (e.key === '/' && !['INPUT', 'TEXTAREA'].includes(document.activeElement.tagName)) {
        e.preventDefault();
        
        if (!openSearchBtn.disabled) {
            pdfSearchSection.style.display = 'block';
            pdfSearchBox.focus();
        }
    }
    
    if (e.key === 'Escape' && pdfSearchSection.style.display === 'block') {
        pdfSearchSection.style.display = 'none';
        pdfSearchBox.value = '';
        searchResults.innerHTML = '';
        searchStatus.textContent = '';
    }
});

document.addEventListener('keydown', (e) => {
    const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
    const modifier = isMac ? e.metaKey : e.ctrlKey;
    
    if (modifier && e.key === '/' && pdfSearchSection.style.display === 'block') {
        e.preventDefault();
        document.getElementById('clearSearch').click();
    }
    
    if (e.key === '/' && !['INPUT', 'TEXTAREA'].includes(document.activeElement.tagName)) {
        e.preventDefault();
        
        if (!openSearchBtn.disabled) {
            pdfSearchSection.style.display = 'block';
            pdfSearchBox.focus();
        }
    }
    
    if (e.key === 'Escape' && pdfSearchSection.style.display === 'block') {
        pdfSearchSection.style.display = 'none';
        pdfSearchBox.value = '';
        searchResults.innerHTML = '';
        searchStatus.textContent = '';
    }
});

function performSearch(query) {
    if (!pdfSearchIndex) return;

    const fuzzy = document.getElementById('searchFuzzy').checked ? 0.2 : 0;
    const prefix = document.getElementById('searchPrefix').checked;

    try {
        const hasQuotes = /["']/.test(query);
        
        if (hasQuotes) {
            const quotedPhrases = query.match(/["']([^"']+)["']/g) || [];
            const exactPhrases = quotedPhrases.map(p => p.replace(/["']/g, '').toLowerCase());
            
            const exactMatches = pdfSearchChunks.filter(chunk => {
                return exactPhrases.every(phrase => chunk.text.includes(phrase));
            });
            
            const results = exactMatches.map((chunk, index) => ({
                id: chunk.id,
                score: 100 - index,
                page: chunk.page,
                preview: chunk.preview
            }));
            
            displaySearchResults(results, query);
            return;
        }
        
        const results = pdfSearchIndex.search(query.toLowerCase(), {
            fuzzy: fuzzy,
            prefix: prefix,
            combineWith: 'AND'
        });

        const bestPerPage = new Map();
        results.forEach(r => {
            const chunk = pdfSearchChunks.find(c => c.id === r.id);
            if (!chunk) return;
            
            if (!bestPerPage.has(chunk.page) || bestPerPage.get(chunk.page).score < r.score) {
                bestPerPage.set(chunk.page, {
                    ...r,
                    page: chunk.page,
                    preview: chunk.preview
                });
            }
        });

        const sortedResults = Array.from(bestPerPage.values())
            .sort((a, b) => b.score - a.score)
            .slice(0, 30);

        displaySearchResults(sortedResults, query);

    } catch (error) {
        console.error('Search error:', error);
        searchResults.innerHTML = '<div style="padding: 10px; color: #e74c3c;">Search error</div>';
    }
}

function displaySearchResults(results, query) {
    if (results.length === 0) {
        searchResults.innerHTML = '<div style="padding: 20px; color: #888; text-align: center;">No results found</div>';
        searchStatus.textContent = '0 results';
        return;
    }

    searchStatus.textContent = `${results.length} result${results.length === 1 ? '' : 's'} found`;

    const hasQuotes = /["']/.test(query);
    let terms = [];
    
    if (hasQuotes) {
        const quotedPhrases = query.match(/["']([^"']+)["']/g) || [];
        terms = quotedPhrases.map(p => p.replace(/["']/g, '').toLowerCase());
    } else {
        terms = query.toLowerCase().split(/\s+/).filter(t => t.length >= 2);
    }
    
    const fuzzyEnabled = document.getElementById('searchFuzzy').checked;

    searchResults.innerHTML = results.map(result => {
        let displayText = result.preview || '';
        
        if (hasQuotes) {
            terms.forEach(phrase => {
                const regex = new RegExp(`(${escapeRegex(phrase)})`, 'gi');
                displayText = displayText.replace(regex, '<mark>$1</mark>');
            });
        } else {
            terms.forEach(term => {
                if (fuzzyEnabled) {
                    const fuzzyRegex = new RegExp(`\\b(${escapeRegex(term)}[a-z]{0,3})\\b`, 'gi');
                    displayText = displayText.replace(fuzzyRegex, '<mark>$1</mark>');
                } else {
                    const regex = new RegExp(`\\b(${escapeRegex(term)}[a-z]*)\\b`, 'gi');
                    displayText = displayText.replace(regex, '<mark>$1</mark>');
                }
            });
        }

        return `
            <div class="search-result-item" data-page="${result.page}">
                <div class="search-result-header">
                    <span class="search-result-page">Page ${result.page}</span>
                    <span class="search-result-score">${result.score.toFixed(1)}</span>
                </div>
                <div class="search-result-text">${displayText}</div>
            </div>
        `;
    }).join('');

    searchResults.querySelectorAll('.search-result-item').forEach(item => {
        item.addEventListener('click', async () => {
            const pageNum = parseInt(item.dataset.page);
            
            const scale = currentZoomScale;
            await renderPage(pageNum, scale);
            
            scrollToPage(pageNum);
            
            await highlightSearchTermsOnPage(pageNum, terms);
        });
    });
}

async function highlightSearchTermsOnPage(pageNum, terms) {
    const pageContainer = document.querySelector(`.pdf-page-container[data-page-number="${pageNum}"]`);
    if (!pageContainer) return;

    const textLayerDiv = pageContainer.querySelector('.textLayer');
    if (!textLayerDiv) return;

    const textDivs = textLayerDiv.querySelectorAll('span');
    
    const highlights = [];
    
    textDivs.forEach(textDiv => {
        const text = textDiv.textContent.toLowerCase();
        
        const hasMatch = terms.some(term => text.includes(term));
        
        if (hasMatch) {
            const rect = textDiv.getBoundingClientRect();
            const containerRect = pageContainer.getBoundingClientRect();
            
            const highlight = document.createElement('div');
            highlight.style.position = 'absolute';
            highlight.style.left = (rect.left - containerRect.left) + 'px';
            highlight.style.top = (rect.top - containerRect.top) + 'px';
            highlight.style.width = rect.width + 'px';
            highlight.style.height = rect.height + 'px';
            highlight.style.backgroundColor = 'rgba(255, 255, 0, 0.4)';
            highlight.style.border = '2px solid rgba(255, 200, 0, 0.8)';
            highlight.style.pointerEvents = 'none';
            highlight.style.zIndex = '100';
            highlight.style.transition = 'opacity 0.5s';
            highlight.className = 'search-highlight-overlay';
            
            pageContainer.appendChild(highlight);
            highlights.push(highlight);
        }
    });

    if (highlights.length > 0) {
        setTimeout(() => {
            highlights.forEach(h => {
                h.style.opacity = '0';
                setTimeout(() => h.remove(), 500);
            });
        }, 4000);
    }
}

function escapeRegex(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

let pdfColorMode = localStorage.getItem('pdfColorMode') || 'grayscale';

const togglePdfDarkModeBtn = document.getElementById('togglePdfDarkMode');

togglePdfDarkModeBtn.addEventListener('click', () => {
    if (pdfColorMode === 'grayscale') {
        pdfColorMode = 'dark';
    } else if (pdfColorMode === 'dark') {
        pdfColorMode = 'light';
    } else {
        pdfColorMode = 'grayscale';
    }
    
    localStorage.setItem('pdfColorMode', pdfColorMode);
    applyPdfColorMode();
});

function applyPdfColorMode() {
    const allCanvases = pdfViewerContainer.querySelectorAll('.pdf-page');
    
    allCanvases.forEach(canvas => {
        canvas.classList.remove('dark-mode', 'grayscale-mode');
        
        if (pdfColorMode === 'dark') {
            canvas.classList.add('dark-mode');
        } else if (pdfColorMode === 'grayscale') {
            canvas.classList.add('grayscale-mode');
        }
    });
    
    if (pdfColorMode === 'dark') {
        togglePdfDarkModeBtn.textContent = 'üåô';
        togglePdfDarkModeBtn.title = 'Dark mode (click for light)';
    } else if (pdfColorMode === 'grayscale') {
        togglePdfDarkModeBtn.textContent = 'üåó';
        togglePdfDarkModeBtn.title = 'Grayscale mode (click for dark)';
    } else {
        togglePdfDarkModeBtn.textContent = '‚òÄÔ∏è';
        togglePdfDarkModeBtn.title = 'Light mode (click for grayscale)';
    }
}

function initializeColorMode() {
    if (pdfColorMode === 'dark') {
        togglePdfDarkModeBtn.textContent = 'üåô';
        togglePdfDarkModeBtn.title = 'Dark mode (click for light)';
    } else if (pdfColorMode === 'grayscale') {
        togglePdfDarkModeBtn.textContent = 'üåó';
        togglePdfDarkModeBtn.title = 'Grayscale mode (click for dark)';
    } else {
        togglePdfDarkModeBtn.textContent = '‚òÄÔ∏è';
        togglePdfDarkModeBtn.title = 'Light mode (click for grayscale)';
    }
}

initializeColorMode();

    </script>
</body>
</html>
</body>
</html>